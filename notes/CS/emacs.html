<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Emacs</title>
  <style>
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <link rel="stylesheet" href="/static/custom.css" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header id="title-block-header">
<h1 class="title">Emacs</h1>
</header>
<nav id="TOC" role="doc-toc">
<ul>
<li><a href="#tramp"><span class="toc-section-number">1</span> tramp</a><ul>
<li><a href="#管道"><span class="toc-section-number">1.1</span> 管道</a></li>
</ul></li>
<li><a href="#org"><span class="toc-section-number">2</span> org</a><ul>
<li><a href="#代码块"><span class="toc-section-number">2.1</span> 代码块</a><ul>
<li><a href="#代码块的执行路径"><span class="toc-section-number">2.1.1</span> 代码块的执行路径</a></li>
</ul></li>
<li><a href="#结构化编辑"><span class="toc-section-number">2.2</span> 结构化编辑</a><ul>
<li><a href="#描述性列表"><span class="toc-section-number">2.2.1</span> 描述性列表</a></li>
<li><a href="#脚注"><span class="toc-section-number">2.2.2</span> 脚注</a></li>
<li><a href="#常用的结构化快捷方式"><span class="toc-section-number">2.2.3</span> 常用的结构化快捷方式</a></li>
<li><a href="#参考"><span class="toc-section-number">2.2.4</span> 参考</a></li>
</ul></li>
</ul></li>
<li><a href="#编码转换"><span class="toc-section-number">3</span> 编码转换</a><ul>
<li><a href="#参考-1"><span class="toc-section-number">3.1</span> 参考</a></li>
</ul></li>
<li><a href="#elisp中变量的定义"><span class="toc-section-number">4</span> elisp中变量的定义</a><ul>
<li><a href="#exec-path-path-和-load-path-的区别"><span class="toc-section-number">4.1</span> <code>exec-path</code> , <code>$PATH</code> 和 <code>load-path</code> 的区别</a><ul>
<li><a href="#参考-2"><span class="toc-section-number">4.1.1</span> 参考</a></li>
</ul></li>
</ul></li>
<li><a href="#录制宏"><span class="toc-section-number">5</span> 录制宏</a></li>
<li><a href="#ibuffer"><span class="toc-section-number">6</span> ibuffer</a><ul>
<li><a href="#分组"><span class="toc-section-number">6.1</span> 分组</a></li>
</ul></li>
</ul>
</nav>
<h1 id="tramp"><span class="header-section-number">1</span> tramp</h1>
<h2 id="管道"><span class="header-section-number">1.1</span> 管道</h2>
<p>考虑这样一个场景：使用tramp访问远端的文件，且该文件需要root权限，当然tramp时直接使用root是一种方式，另一种方式是使用管道解决：</p>
<pre class="example"><code>    /ssh:user@&lt;ip&gt;|sudo:/etc/network/interfaces</code></pre>
<h1 id="org"><span class="header-section-number">2</span> org</h1>
<h2 id="代码块"><span class="header-section-number">2.1</span> 代码块</h2>
<h3 id="代码块的执行路径"><span class="header-section-number">2.1.1</span> 代码块的执行路径</h3>
<p>org中的代码块可以增加一个dir参数用于指定命令执行的路径，而且该dir参数也支持tramp：</p>
<pre class="example"><code>    grep home passwd</code></pre>
<h2 id="结构化编辑"><span class="header-section-number">2.2</span> 结构化编辑</h2>
<h3 id="描述性列表"><span class="header-section-number">2.2.1</span> 描述性列表</h3>
<pre><code>Elijah Wood :: He plays Frodo;</code></pre>
<h3 id="脚注"><span class="header-section-number">2.2.2</span> 脚注</h3>
<p><code>C-c C-x f</code> 可以在当前位置插入一个脚注， <code>C-c C-c</code> 在脚注和标记的内容之间切换。</p>
<h3 id="常用的结构化快捷方式"><span class="header-section-number">2.2.3</span> 常用的结构化快捷方式</h3>
<table>
<thead>
<tr class="header">
<th>commannd</th>
<th>shortcuts</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>next/previous heading</td>
<td>C-c C-n/p</td>
</tr>
<tr class="even">
<td>next/previous heading</td>
<td>C-c C-n/p</td>
</tr>
<tr class="odd">
<td>next/previous heading, same level</td>
<td>C-c C-f/b</td>
</tr>
<tr class="even">
<td>backward to higher level heading</td>
<td>C-c C-u</td>
</tr>
<tr class="odd">
<td>jump to another place in document</td>
<td>C-c C-j</td>
</tr>
<tr class="even">
<td>previous/next plain list item</td>
<td>S-UP/DOWN</td>
</tr>
<tr class="odd">
<td>insert new heading/item at current level</td>
<td>M-RET</td>
</tr>
<tr class="even">
<td>insert new heading after subtree</td>
<td>C-RET</td>
</tr>
<tr class="odd">
<td>insert new TODO entry/checkbox item</td>
<td>M-S-RET</td>
</tr>
<tr class="even">
<td>insert TODO entry/ckbx after subtree</td>
<td>C-S-RET</td>
</tr>
<tr class="odd">
<td>turn (head)line into item, cycle item type</td>
<td>C-c -</td>
</tr>
<tr class="even">
<td>turn item/line into headline</td>
<td>C-c *</td>
</tr>
<tr class="odd">
<td>promote/demote heading</td>
<td>M-LEFT/RIGHT</td>
</tr>
<tr class="even">
<td>promote/demote current subtree</td>
<td>M-S-LEFT/RIGHT</td>
</tr>
<tr class="odd">
<td>move subtree/list item up/down</td>
<td>M-S-UP/DOWN</td>
</tr>
<tr class="even">
<td>sort subtree/region/plain-list</td>
<td>C-c ^</td>
</tr>
<tr class="odd">
<td>clone a subtree</td>
<td>C-c C-x c</td>
</tr>
<tr class="even">
<td>refile subtree</td>
<td>C-c C-w</td>
</tr>
<tr class="odd">
<td>kill/copy subtree</td>
<td>C-c C-x C-w/M-w</td>
</tr>
<tr class="even">
<td>yank subtree</td>
<td>C-c C-x C-y or C-y</td>
</tr>
<tr class="odd">
<td>narrow buffer to subtree / widen</td>
<td>C-x n s/w</td>
</tr>
</tbody>
</table>
<h3 id="参考"><span class="header-section-number">2.2.4</span> 参考</h3>
<ul>
<li><a href="http://caole.net/diary/org_mode.html">Emacs org mode 学习笔记</a></li>
</ul>
<h1 id="编码转换"><span class="header-section-number">3</span> 编码转换</h1>
<p>编码转换：</p>
<pre class="example"><code>    C-x C-m f utf-8-unix RET   ;;即可把当前文件转换为 utf-8 编码（前提是要首先转换成可以识别的编码）。
    C-x C-m c RET C-x C-w RET ;;另存为指定编码的(会提示当前文件编码)
    C-x C-m r    ;;以特定的编码重新打开当前文件</code></pre>
<h2 id="参考-1"><span class="header-section-number">3.1</span> 参考</h2>
<ul>
<li><a href="http://www.cnblogs.com/ruizhe/archive/2010/12/02/1894506.html">emacs 转换文件编码</a></li>
</ul>
<h1 id="elisp中变量的定义"><span class="header-section-number">4</span> elisp中变量的定义</h1>
<h2 id="exec-path-path-和-load-path-的区别"><span class="header-section-number">4.1</span> <code>exec-path</code> , <code>$PATH</code> 和 <code>load-path</code> 的区别</h2>
<p><code>exec-path</code> 是emacs查找可执行文件的路径， <code>exec-path</code> 只在emacs启动时从 <code>$PATH</code> 中读取值进行初始化。</p>
<p><code>$PATH</code> 自然就是用于执行shell中的命令或者 <code>M-!</code> 执行的命令。</p>
<p><code>load-path</code> 则是emacs导入elisp的路径。</p>
<h3 id="参考-2"><span class="header-section-number">4.1.1</span> 参考</h3>
<ul>
<li><a href="https://emacs.stackexchange.com/questions/550/exec-path-and-path">exec-path and $PATH</a></li>
</ul>
<h1 id="录制宏"><span class="header-section-number">5</span> 录制宏</h1>
<p><code>C-x (</code> 开始录制， <code>C-x )</code> 结束录制， <code>C-x e</code> 单次执行宏， <code>C-u 10 C-x e</code> 执行宏10次。</p>
<h1 id="ibuffer"><span class="header-section-number">6</span> ibuffer</h1>
<h2 id="分组"><span class="header-section-number">6.1</span> 分组</h2>
<table>
<thead>
<tr class="header">
<th>key</th>
<th>bindings</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>/ m</td>
<td>基于major mode设定一个筛选条件</td>
</tr>
<tr class="even">
<td>/ n</td>
<td>基于buffer name设定一个筛选条件</td>
</tr>
<tr class="odd">
<td>/ c</td>
<td>基于buffer 的内容设定一个筛选条件</td>
</tr>
<tr class="even">
<td>/ f</td>
<td>基于filename 设定一个筛选条件</td>
</tr>
<tr class="odd">
<td>/ &gt;</td>
<td>基于buffer size 设定一个筛选条件</td>
</tr>
<tr class="even">
<td>/ &lt;</td>
<td>也是基于buffer size</td>
</tr>
<tr class="odd">
<td>/ /</td>
<td>删掉所有生效的筛选条件</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr class="header">
<th>key</th>
<th>bindings</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>/ g</td>
<td>根据筛选结果创建分组</td>
</tr>
<tr class="even">
<td>TAB</td>
<td>移动到下一个分组</td>
</tr>
<tr class="odd">
<td>M-p</td>
<td>移动到上一个分组</td>
</tr>
<tr class="even">
<td>/  </td>
<td>删除所有存在的分组</td>
</tr>
</tbody>
</table>
</body>
</html>
