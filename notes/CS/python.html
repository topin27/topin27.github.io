<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Python 相关 notes</title>
  <style>
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <style>
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(title);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" href="/static/custom.css" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header id="title-block-header">
<h1 class="title">Python 相关 notes</h1>
</header>
<nav id="TOC" role="doc-toc">
<ul>
<li><a href="#python中的一些奇怪的点"><span class="toc-section-number">1</span> python中的一些奇怪的点</a><ul>
<li><a href="#编码问题"><span class="toc-section-number">1.1</span> 编码问题</a><ul>
<li><a href="#编码转换及unicode"><span class="toc-section-number">1.1.1</span> 编码转换及unicode</a></li>
<li><a href="#用codecs解决py2中写入文件编码的问题"><span class="toc-section-number">1.1.2</span> 用codecs解决py2中写入文件编码的问题</a></li>
<li><a href="#检测编码"><span class="toc-section-number">1.1.3</span> 检测编码</a></li>
</ul></li>
<li><a href="#打开文件"><span class="toc-section-number">1.2</span> 打开文件</a></li>
<li><a href="#list操作tricks"><span class="toc-section-number">1.3</span> list操作tricks</a><ul>
<li><a href="#对list进行切分"><span class="toc-section-number">1.3.1</span> 对list进行切分</a></li>
</ul></li>
<li><a href="#时间相关操作"><span class="toc-section-number">1.4</span> 时间相关操作</a><ul>
<li><a href="#对带时区信息的字符串进行解析"><span class="toc-section-number">1.4.1</span> 对带时区信息的字符串进行解析</a></li>
</ul></li>
<li><a href="#迭代器"><span class="toc-section-number">1.5</span> 迭代器</a></li>
</ul></li>
<li><a href="#快速方便的达到一些奇怪的目的"><span class="toc-section-number">2</span> 快速方便的达到一些奇怪的目的</a><ul>
<li><a href="#计算字符串的相似度"><span class="toc-section-number">2.1</span> 计算字符串的相似度</a></li>
<li><a href="#with语法"><span class="toc-section-number">2.2</span> with语法</a><ul>
<li><a href="#同时打开两个文件"><span class="toc-section-number">2.2.1</span> 同时打开两个文件</a></li>
<li><a href="#实现with-clause"><span class="toc-section-number">2.2.2</span> 实现<code>with</code> clause</a></li>
</ul></li>
<li><a href="#os.walk-遍历文件夹下所有文件"><span class="toc-section-number">2.3</span> <code>os.walk()</code> 遍历文件夹下所有文件</a></li>
<li><a href="#嵌套for循环的简化"><span class="toc-section-number">2.4</span> 嵌套for循环的简化</a></li>
</ul></li>
<li><a href="#logging"><span class="toc-section-number">3</span> Logging</a><ul>
<li><a href="#loggers"><span class="toc-section-number">3.1</span> loggers</a><ul>
<li><a href="#使用logger记录异常"><span class="toc-section-number">3.1.1</span> 使用logger记录异常</a></li>
<li><a href="#不要在模块级别调用-getlogger"><span class="toc-section-number">3.1.2</span> <del>不要在模块级别调用 <code>getLogger</code></del></a></li>
</ul></li>
<li><a href="#handlers"><span class="toc-section-number">3.2</span> Handlers</a></li>
<li><a href="#filters"><span class="toc-section-number">3.3</span> Filters</a></li>
<li><a href="#formatters"><span class="toc-section-number">3.4</span> Formatters</a></li>
</ul></li>
<li><a href="#pip"><span class="toc-section-number">4</span> pip</a><ul>
<li><a href="#在本地安装包及其依赖"><span class="toc-section-number">4.1</span> 在本地安装包及其依赖</a></li>
</ul></li>
<li><a href="#包导入"><span class="toc-section-number">5</span> 包导入</a></li>
<li><a href="#性能优化"><span class="toc-section-number">6</span> 性能优化</a><ul>
<li><a href="#profile包"><span class="toc-section-number">6.1</span> profile包</a></li>
<li><a href="#并行化"><span class="toc-section-number">6.2</span> 并行化</a></li>
</ul></li>
<li><a href="#正则表达式"><span class="toc-section-number">7</span> 正则表达式</a><ul>
<li><a href="#替换一部分字符串"><span class="toc-section-number">7.1</span> 替换一部分字符串</a></li>
<li><a href="#lookahead"><span class="toc-section-number">7.2</span> lookahead</a></li>
</ul></li>
<li><a href="#函数式编程"><span class="toc-section-number">8</span> 函数式编程</a><ul>
<li><a href="#偏函数"><span class="toc-section-number">8.1</span> 偏函数</a></li>
</ul></li>
</ul>
</nav>
<h1 id="python中的一些奇怪的点"><span class="header-section-number">1</span> python中的一些奇怪的点</h1>
<h2 id="编码问题"><span class="header-section-number">1.1</span> 编码问题</h2>
<h3 id="编码转换及unicode"><span class="header-section-number">1.1.1</span> 编码转换及unicode</h3>
<p>python2中， <code>encode()</code> 函数是将unicode转换为str，而 <code>decode()</code> 是将str转换为unicode。</p>
<h3 id="用codecs解决py2中写入文件编码的问题"><span class="header-section-number">1.1.2</span> 用codecs解决py2中写入文件编码的问题</h3>
<p>使用open打开的文件写入时，对于非ascii码的字符串写入，需要先将其decode为unicode，再encode为str才能写入。可以使用codecs代替这些繁琐的操作：</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb1-1" title="1">    <span class="im">import</span> codecs</a>
<a class="sourceLine" id="cb1-2" title="2"></a>
<a class="sourceLine" id="cb1-3" title="3">    line <span class="op">=</span> <span class="st">u&#39;这是一个测试字符串&#39;</span></a>
<a class="sourceLine" id="cb1-4" title="4">    fw <span class="op">=</span> codecs.<span class="bu">open</span>(<span class="st">&#39;test.txt&#39;</span>, <span class="st">&#39;a&#39;</span>, <span class="st">&#39;utf-8&#39;</span>)</a>
<a class="sourceLine" id="cb1-5" title="5">    fw.write(line)</a></code></pre></div>
<p>使用这中方式打开的文件读取返回的字符串默认就是 unicode 的。写入时，如果字符串时 unicode 的，则使用调用 <code>codecs.open()</code> 时指定的编码进行编码后写入，如果字符串时 str 类型的，则先根据源代码文件声明的字符编码，解码成 unicode 后再进行前述操作。</p>
<h3 id="检测编码"><span class="header-section-number">1.1.3</span> 检测编码</h3>
<p>使用 <code>chardet</code> 可以猜测字符串的编码，使用方式：</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb2-1" title="1">    <span class="im">import</span> chardet</a>
<a class="sourceLine" id="cb2-2" title="2">    chardet.detect(<span class="st">&#39;some string to detect for your own&#39;</span>)</a></code></pre></div>
<p>对于文件较大的情况，可以检测一部分来加快速度：</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb3-1" title="1">    <span class="im">from</span> chardet.universaldetector <span class="im">import</span> UniversalDetector</a>
<a class="sourceLine" id="cb3-2" title="2">    detector <span class="op">=</span> UniversalDetector()</a>
<a class="sourceLine" id="cb3-3" title="3">    <span class="cf">for</span> line <span class="kw">in</span> fp.readlines():</a>
<a class="sourceLine" id="cb3-4" title="4">        <span class="co"># 测试一部分，直到达到阈值</span></a>
<a class="sourceLine" id="cb3-5" title="5">        detector.feed(line)</a>
<a class="sourceLine" id="cb3-6" title="6">        <span class="cf">if</span> detector.done:</a>
<a class="sourceLine" id="cb3-7" title="7">            <span class="cf">break</span></a>
<a class="sourceLine" id="cb3-8" title="8">    detector.close()</a>
<a class="sourceLine" id="cb3-9" title="9">    <span class="bu">print</span> detector.result</a></code></pre></div>
<p>但是通常chardet无法做到完全检测准确，一个简单的 workaround 是通过指定一定的编码类型打开文件并捕获异常：</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb4-1" title="1">    encodings <span class="op">=</span> [<span class="st">&#39;utf-8&#39;</span>, <span class="st">&#39;gbk&#39;</span>, <span class="st">&#39;gb2312&#39;</span>, <span class="st">&#39;gb18030&#39;</span>, <span class="st">&#39;ISO-8859-1&#39;</span>, <span class="st">&#39;windows-1250&#39;</span>, <span class="st">&#39;windows-1252&#39;</span>]</a>
<a class="sourceLine" id="cb4-2" title="2">    <span class="cf">for</span> e <span class="kw">in</span> encodings:</a>
<a class="sourceLine" id="cb4-3" title="3">        <span class="cf">try</span>:</a>
<a class="sourceLine" id="cb4-4" title="4">            fh <span class="op">=</span> codecs.<span class="bu">open</span>(<span class="st">&#39;file.txt&#39;</span>, <span class="st">&#39;r&#39;</span>, encoding<span class="op">=</span>e)</a>
<a class="sourceLine" id="cb4-5" title="5">            fh.readlines()</a>
<a class="sourceLine" id="cb4-6" title="6">            fh.seek(<span class="dv">0</span>)</a>
<a class="sourceLine" id="cb4-7" title="7">        <span class="cf">except</span> <span class="pp">UnicodeDecodeError</span>:</a>
<a class="sourceLine" id="cb4-8" title="8">            <span class="bu">print</span>(<span class="st">&#39;got unicode error with </span><span class="sc">%s</span><span class="st"> , trying different encoding&#39;</span> <span class="op">%</span> e)</a>
<a class="sourceLine" id="cb4-9" title="9">        <span class="cf">else</span>:</a>
<a class="sourceLine" id="cb4-10" title="10">            <span class="bu">print</span>(<span class="st">&#39;opening the file with encoding:  </span><span class="sc">%s</span><span class="st"> &#39;</span> <span class="op">%</span> e)</a>
<a class="sourceLine" id="cb4-11" title="11">            <span class="cf">break</span>  </a>
<a class="sourceLine" id="cb4-12" title="12">    <span class="cf">else</span>:</a>
<a class="sourceLine" id="cb4-13" title="13">        <span class="bu">print</span>(<span class="st">&#39;no valid encoder&#39;</span>)</a></code></pre></div>
<h2 id="打开文件"><span class="header-section-number">1.2</span> 打开文件</h2>
<p>Python2中打开文件是 <code>open</code> ，默认是 <code>File.open</code> ，但是在Python3中 <code>open</code> 被移到了 <code>io</code> 模块，因此在Python 2.6开始，引入了 <code>io.open</code> ，以兼容Python 3。</p>
<p><code>io.open</code> 需要多加一个参数指定编码，效果几乎同 <code>codecs.open</code> ，但是似乎在 Python 2.6 中 <code>io.open</code> 有bug会导致奇怪的问题，该问题在Python 2.7中已经修复。</p>
<h2 id="list操作tricks"><span class="header-section-number">1.3</span> list操作tricks</h2>
<h3 id="对list进行切分"><span class="header-section-number">1.3.1</span> 对list进行切分</h3>
<div class="sourceCode" id="cb5"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb5-1" title="1">    <span class="im">import</span> numpy <span class="im">as</span> np</a>
<a class="sourceLine" id="cb5-2" title="2"></a>
<a class="sourceLine" id="cb5-3" title="3">    lst <span class="op">=</span> <span class="bu">range</span>(<span class="dv">50</span>)</a>
<a class="sourceLine" id="cb5-4" title="4">    np.array_split(lst, <span class="dv">5</span>)</a></code></pre></div>
<h2 id="时间相关操作"><span class="header-section-number">1.4</span> 时间相关操作</h2>
<h3 id="对带时区信息的字符串进行解析"><span class="header-section-number">1.4.1</span> 对带时区信息的字符串进行解析</h3>
<div class="sourceCode" id="cb6"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb6-1" title="1">    <span class="im">from</span> dateutil.parser <span class="im">import</span> parse</a>
<a class="sourceLine" id="cb6-2" title="2">    d <span class="op">=</span> parse(<span class="st">&quot;2012-11-01T04:16:13-04:00&quot;</span>)</a></code></pre></div>
<h2 id="迭代器"><span class="header-section-number">1.5</span> 迭代器</h2>
<p>迭代器的一个最大的特点是不可再现，即如果对其进行遍历，如果遍历完成，再次进行遍历则不会迭代出任何结果，原因是其内部维护状态的状态并不会更新。而显式的遍历通常可以注意避免，一些隐式的遍历则是防不胜防，比如：<code>list(iterator)</code>进行转换后，整个迭代器内部也是已经完成了遍历的状态，整个迭代器无法再次使用。</p>
<h1 id="快速方便的达到一些奇怪的目的"><span class="header-section-number">2</span> 快速方便的达到一些奇怪的目的</h1>
<h2 id="计算字符串的相似度"><span class="header-section-number">2.1</span> 计算字符串的相似度</h2>
<p>使用difflib，参考：<a href="https://www.deeplearn.me/1125.html" class="uri">https://www.deeplearn.me/1125.html</a></p>
<div class="sourceCode" id="cb7"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb7-1" title="1">    <span class="im">from</span> difflib <span class="im">import</span> SequenceMatcher</a>
<a class="sourceLine" id="cb7-2" title="2">    <span class="kw">def</span> similar(a, b):</a>
<a class="sourceLine" id="cb7-3" title="3">        <span class="cf">return</span> SequenceMatcher(<span class="va">None</span>, a, b).ratio()</a>
<a class="sourceLine" id="cb7-4" title="4">    similar(<span class="st">&#39;Apple&#39;</span>, <span class="st">&#39;Appel&#39;</span>)</a></code></pre></div>
<h2 id="with语法"><span class="header-section-number">2.2</span> with语法</h2>
<h3 id="同时打开两个文件"><span class="header-section-number">2.2.1</span> 同时打开两个文件</h3>
<div class="sourceCode" id="cb8"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb8-1" title="1">    <span class="cf">with</span> <span class="bu">open</span>(<span class="st">&#39;a&#39;</span>, <span class="st">&#39;w&#39;</span>) <span class="im">as</span> a, <span class="bu">open</span>(<span class="st">&#39;b&#39;</span>, <span class="st">&#39;w&#39;</span>) <span class="im">as</span> b:</a>
<a class="sourceLine" id="cb8-2" title="2">        do_something()</a></code></pre></div>
<h3 id="实现with-clause"><span class="header-section-number">2.2.2</span> 实现<code>with</code> clause</h3>
<div class="sourceCode" id="cb9"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb9-1" title="1">    <span class="kw">class</span> Meter():</a>
<a class="sourceLine" id="cb9-2" title="2">        <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, filepath):</a>
<a class="sourceLine" id="cb9-3" title="3">            <span class="va">self</span>.filepath <span class="op">=</span> filepath</a>
<a class="sourceLine" id="cb9-4" title="4">        <span class="kw">def</span> <span class="fu">__enter__</span>(<span class="va">self</span>):</a>
<a class="sourceLine" id="cb9-5" title="5">            <span class="co">#ttysetattr etc goes here before opening and returning the file object</span></a>
<a class="sourceLine" id="cb9-6" title="6">            <span class="va">self</span>.fd <span class="op">=</span> <span class="bu">open</span>(<span class="va">self</span>.filepath, <span class="st">&#39;r&#39;</span>)</a>
<a class="sourceLine" id="cb9-7" title="7">            <span class="cf">return</span> <span class="va">self</span>.fd</a>
<a class="sourceLine" id="cb9-8" title="8">        <span class="kw">def</span> <span class="fu">__exit__</span>(<span class="va">self</span>, <span class="bu">type</span>, value, traceback):</a>
<a class="sourceLine" id="cb9-9" title="9">            <span class="co">#Exception handling here</span></a>
<a class="sourceLine" id="cb9-10" title="10">        <span class="va">self</span>.fd.close()</a>
<a class="sourceLine" id="cb9-11" title="11"></a>
<a class="sourceLine" id="cb9-12" title="12">    meter <span class="op">=</span> Meter(<span class="st">&#39;dev/tty0&#39;</span>)</a>
<a class="sourceLine" id="cb9-13" title="13">    <span class="cf">with</span> meter <span class="im">as</span> m:</a>
<a class="sourceLine" id="cb9-14" title="14">        <span class="co">#here you work with the file object.</span></a>
<a class="sourceLine" id="cb9-15" title="15">        m.read()</a></code></pre></div>
<p>或者</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb10-1" title="1">    <span class="im">import</span> contextlib</a>
<a class="sourceLine" id="cb10-2" title="2"></a>
<a class="sourceLine" id="cb10-3" title="3">    <span class="at">@contextlib.contextmanager</span></a>
<a class="sourceLine" id="cb10-4" title="4">    <span class="kw">def</span> themeter(name):</a>
<a class="sourceLine" id="cb10-5" title="5">        theobj <span class="op">=</span> Meter(name)</a>
<a class="sourceLine" id="cb10-6" title="6">        <span class="cf">yield</span> theobj</a>
<a class="sourceLine" id="cb10-7" title="7">        theobj.close()  <span class="co"># or whatever you need to do at exit</span></a></code></pre></div>
<h2 id="os.walk-遍历文件夹下所有文件"><span class="header-section-number">2.3</span> <code>os.walk()</code> 遍历文件夹下所有文件</h2>
<div class="sourceCode" id="cb11"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb11-1" title="1">    <span class="cf">for</span> root, _, files <span class="kw">in</span> os.walk(<span class="st">&#39;.&#39;</span>):</a>
<a class="sourceLine" id="cb11-2" title="2">        <span class="cf">for</span> f <span class="kw">in</span> files:</a>
<a class="sourceLine" id="cb11-3" title="3">            <span class="bu">print</span> os.path.join(root, f)</a></code></pre></div>
<h2 id="嵌套for循环的简化"><span class="header-section-number">2.4</span> 嵌套for循环的简化</h2>
<div class="sourceCode" id="cb12"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb12-1" title="1">    <span class="cf">for</span> x <span class="kw">in</span> x_list:</a>
<a class="sourceLine" id="cb12-2" title="2">        <span class="cf">for</span> y <span class="kw">in</span> y_list:</a>
<a class="sourceLine" id="cb12-3" title="3">            <span class="cf">pass</span></a></code></pre></div>
<p>可以简化成：</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb13-1" title="1">    <span class="im">from</span> itertools <span class="im">import</span> product</a>
<a class="sourceLine" id="cb13-2" title="2">    <span class="cf">for</span> x, y <span class="kw">in</span> product(x_list, y_list):</a>
<a class="sourceLine" id="cb13-3" title="3">        <span class="co"># do something on x and y.</span></a>
<a class="sourceLine" id="cb13-4" title="4">        <span class="cf">pass</span></a></code></pre></div>
<h1 id="logging"><span class="header-section-number">3</span> Logging</h1>
<h2 id="loggers"><span class="header-section-number">3.1</span> loggers</h2>
<p>通常通过 <code>logging.getLogger(name)</code> 来获取，logging模块整体多线程安全，但是不支持多进程。logger对象有父子关系，当没有父logger对象时，它的父对象就是root，如果某一个logger对象打日志时，它的父对象会同时收到日志。</p>
<p>一个简单的获取root logger的方式是：</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb14-1" title="1">    logging.basicConfig(level<span class="op">=</span>logging.INFO, filename<span class="op">=</span><span class="st">&#39;logger.log&#39;</span>)</a>
<a class="sourceLine" id="cb14-2" title="2">    logging.info(<span class="st">&quot;info message&quot;</span>)</a></code></pre></div>
<p>暂时向标准输出打印日志：</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb15-1" title="1">    logging.basicConfig(stream<span class="op">=</span>sys.stdout, level<span class="op">=</span>logging.DEBUG)</a></code></pre></div>
<h3 id="使用logger记录异常"><span class="header-section-number">3.1.1</span> 使用logger记录异常</h3>
<div class="sourceCode" id="cb16"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb16-1" title="1">    <span class="cf">try</span>:</a>
<a class="sourceLine" id="cb16-2" title="2">        <span class="bu">open</span>(<span class="st">&#39;/path/to/does/not/exist&#39;</span>, <span class="st">&#39;rb&#39;</span>)</a>
<a class="sourceLine" id="cb16-3" title="3">    <span class="cf">except</span> (<span class="pp">SystemExit</span>, <span class="pp">KeyboardInterrupt</span>):</a>
<a class="sourceLine" id="cb16-4" title="4">        <span class="cf">raise</span></a>
<a class="sourceLine" id="cb16-5" title="5">    <span class="cf">except</span> <span class="pp">Exception</span>, e:</a>
<a class="sourceLine" id="cb16-6" title="6">        logger.error(<span class="st">&#39;Failed to open file&#39;</span>, exc_info<span class="op">=</span><span class="va">True</span>)</a></code></pre></div>
<h3 id="不要在模块级别调用-getlogger"><span class="header-section-number">3.1.2</span> <del>不要在模块级别调用 <code>getLogger</code></del></h3>
<p><del>这么做的原因是导入模块会导致模块顶级的代码执行，因此会使得 <code>getLogger</code> 函数执行，但是如果导入模块后又调用 <code>logging.fileConfig</code> 或者 <code>logging.dictConfig</code> 等函数来意图初始化logger时，默认这些函数会使得已经存在的logger失效，因此导致日志无法输出。</del></p>
<p>首先，在 main 部分直接使用 <code>basicConfig</code> 并不会使已经存在的 logger 失效，而作为库，默认的行为也应该是被调用的时候不提供日志输出对 main 部分进行干扰。此外，不管是<code>logging.fileConfig</code>还是<code>logging.dictConfig</code>都有一个<code>disable_existing_loggers</code>参数可以调节是否需要禁用已经存在的 logger，以解决该问题。</p>
<p>而且，<a href="https://stackoverflow.com/questions/22807972/python-best-practice-in-terms-of-logging">Python’s rules for software composition 是通过模块来组合代码，而不是类</a>，因此最常见的方式反而是直接在 <code>import</code> 后直接进行：</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb17-1" title="1">    logger <span class="op">=</span> logging.getLogger(<span class="va">__name__</span>)</a></code></pre></div>
<p>这也是很多常见的库（比如 <code>requests</code>, <code>gensim</code>）的做法。</p>
<h2 id="handlers"><span class="header-section-number">3.2</span> Handlers</h2>
<p>Handlers将logger发送过来的日志进行处理（比如发送到特定的文件），每个handler都会有一个日志级别，一个logger可以拥有多个handler因此可以根据不同的日志级别将日志发送给不同的handler。</p>
<h2 id="filters"><span class="header-section-number">3.3</span> Filters</h2>
<p>提供更细粒度的判断。</p>
<h2 id="formatters"><span class="header-section-number">3.4</span> Formatters</h2>
<p>指定打印的布局。</p>
<h1 id="pip"><span class="header-section-number">4</span> pip</h1>
<h2 id="在本地安装包及其依赖"><span class="header-section-number">4.1</span> 在本地安装包及其依赖</h2>
<p>安装gensim及其相关的依赖：</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb18-1" title="1">  <span class="ex">pip</span> install --no-index --find-links=file:///root/pkgs/ gensim</a></code></pre></div>
<h1 id="包导入"><span class="header-section-number">5</span> 包导入</h1>
<p>包的导入分为相对导入和绝对导入，相对导入可以避免包名硬编码带来的问题。</p>
<p>python2默认为相对路径导入，而python3默认为绝对路径导入。而要在python2中使用绝对路径导入，只需：</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb19-1" title="1">    <span class="im">from</span> __future__ <span class="im">import</span> absolute_import</a></code></pre></div>
<h1 id="性能优化"><span class="header-section-number">6</span> 性能优化</h1>
<h2 id="profile包"><span class="header-section-number">6.1</span> profile包</h2>
<p><code>profile</code> 包完全由python实现，对应的 <code>cProfile</code> 包中有一部分由C实现。一个简单的执行方式是：</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb20-1" title="1">    <span class="ex">python</span> -m cProfile test.py </a></code></pre></div>
<p>或者编译为 <code>pstats</code> 模块支持的格式：</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb21-1" title="1">    <span class="ex">python</span> -m cProfile -o funb.prof test.py</a></code></pre></div>
<p>然后使用 <code>pstats</code> 进行分析：</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb22-1" title="1">    <span class="ex">python</span> -c <span class="st">&quot;import pstats; p=pstats.Stats(&#39;del.out&#39;); p.sort_stats(&#39;time&#39;).print_stats()&quot;</span></a></code></pre></div>
<p>找到大致的热点位置后，然后使用 <code>line_profiler</code> 模块来看每行的执行情况。</p>
<h2 id="并行化"><span class="header-section-number">6.2</span> 并行化</h2>
<div class="sourceCode" id="cb23"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb23-1" title="1">    <span class="im">import</span> multiprocessing</a>
<a class="sourceLine" id="cb23-2" title="2"></a>
<a class="sourceLine" id="cb23-3" title="3">    pool <span class="op">=</span> multiprocessing.Pool(processes<span class="op">=</span>multiprocessing.cpu_count())</a>
<a class="sourceLine" id="cb23-4" title="4"></a>
<a class="sourceLine" id="cb23-5" title="5">    <span class="kw">def</span> f(x):</a>
<a class="sourceLine" id="cb23-6" title="6">        <span class="cf">pass</span></a>
<a class="sourceLine" id="cb23-7" title="7"></a>
<a class="sourceLine" id="cb23-8" title="8">    <span class="cf">for</span> i <span class="kw">in</span> pool.imap(f, [<span class="dv">1</span>, <span class="dv">2</span>]):</a>
<a class="sourceLine" id="cb23-9" title="9">        <span class="bu">print</span> i</a></code></pre></div>
<p>但是需要注意的是 <code>Pool.map</code> 无法 pickle 对象或者 inner function ，因此如果有状态需要 共享的话可以考虑实现对象的 <code>__call__</code> 方法，然后通过 <code>object()</code> 传入 <code>Pool.map</code> 。</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb24-1" title="1">    <span class="kw">class</span> PredictFunction(<span class="bu">object</span>):</a>
<a class="sourceLine" id="cb24-2" title="2"></a>
<a class="sourceLine" id="cb24-3" title="3">        <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, predictor, modeltype):</a>
<a class="sourceLine" id="cb24-4" title="4">            <span class="va">self</span>.guesser <span class="op">=</span> Guess()</a>
<a class="sourceLine" id="cb24-5" title="5">            <span class="va">self</span>.predictor <span class="op">=</span> predictor</a>
<a class="sourceLine" id="cb24-6" title="6">            <span class="va">self</span>.modeltype <span class="op">=</span> modeltype</a>
<a class="sourceLine" id="cb24-7" title="7"></a>
<a class="sourceLine" id="cb24-8" title="8">        <span class="kw">def</span> <span class="fu">__call__</span>(<span class="va">self</span>, path):</a>
<a class="sourceLine" id="cb24-9" title="9">            <span class="co"># do something on path</span></a>
<a class="sourceLine" id="cb24-10" title="10">            <span class="cf">pass</span></a>
<a class="sourceLine" id="cb24-11" title="11"></a>
<a class="sourceLine" id="cb24-12" title="12">    f <span class="op">=</span> PredictFunction(predictor, modeltype)</a>
<a class="sourceLine" id="cb24-13" title="13">    pool.imap(f, [<span class="dv">1</span>, <span class="dv">2</span>])</a></code></pre></div>
<h1 id="正则表达式"><span class="header-section-number">7</span> 正则表达式</h1>
<h2 id="替换一部分字符串"><span class="header-section-number">7.1</span> 替换一部分字符串</h2>
<p>有些时候，需要对匹配到的字符串进行部分替换，可以使用<code>group</code>：</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb25-1" title="1">re.sub(<span class="vs">r&#39;(我)(哥|爸)&#39;</span>, <span class="vs">r&#39;他\2&#39;</span>, <span class="st">&#39;我哥和我爸&#39;</span>)</a></code></pre></div>
<p>得到结果：<code>他哥和他爸</code></p>
<h2 id="lookahead"><span class="header-section-number">7.2</span> lookahead</h2>
<p>lookahead 可以用于匹配过滤单词，其语法格式为：</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb26-1" title="1">    <span class="co"># 满足肯定条件过滤</span></a>
<a class="sourceLine" id="cb26-2" title="2">    (?<span class="op">=</span>expr1)(?<span class="op">=</span>expr2)</a></code></pre></div>
<div class="sourceCode" id="cb27"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb27-1" title="1">    <span class="co"># 满足否定条件过滤</span></a>
<a class="sourceLine" id="cb27-2" title="2">    (?<span class="op">!</span>expr)</a></code></pre></div>
<p>如：</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb28-1" title="1">    (?<span class="op">=\</span>bfoo<span class="op">\</span>b<span class="op">|\</span>bbar<span class="op">\</span>b)<span class="op">\</span>b<span class="op">\</span>w<span class="op">+\</span>b</a></code></pre></div>
<p>将会匹配一句话中所有不是“foo”且不是“bar”的单词。</p>
<p><strong>注意：</strong> lookahead 是“zero-width”的，即<a href="https://stackoverflow.com/questions/9952169/negative-look-ahead-python-regex">他们不占用任何的字符位置空间</a>，因此在匹配的时候除了指定 lookahead 之外，还需要额外的表达式。</p>
<h1 id="函数式编程"><span class="header-section-number">8</span> 函数式编程</h1>
<h2 id="偏函数"><span class="header-section-number">8.1</span> 偏函数</h2>
<p><code>functools</code>中的<code>partial</code>提供了类似于偏函数的能力：</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb29-1" title="1"><span class="kw">def</span> foo(a, b<span class="op">=</span><span class="dv">2</span>, c<span class="op">=</span><span class="dv">3</span>):</a>
<a class="sourceLine" id="cb29-2" title="2">    <span class="bu">print</span>(a, b, c)</a>
<a class="sourceLine" id="cb29-3" title="3"></a>
<a class="sourceLine" id="cb29-4" title="4">f <span class="op">=</span> partial(b<span class="op">=</span><span class="dv">3</span>)</a>
<a class="sourceLine" id="cb29-5" title="5"></a>
<a class="sourceLine" id="cb29-6" title="6">f(<span class="st">&#39;hello&#39;</span>)</a></code></pre></div>
<p>输出：<code>hello 3 3</code></p>
</body>
</html>
