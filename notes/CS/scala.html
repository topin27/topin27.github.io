<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>scala</title>
  <style>
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <style>
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(title);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" href="/static/custom.css" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header id="title-block-header">
<h1 class="title">scala</h1>
</header>
<nav id="TOC" role="doc-toc">
<ul>
<li><a href="#基础语法"><span class="toc-section-number">1</span> 基础语法</a><ul>
<li><a href="#标识符"><span class="toc-section-number">1.1</span> 标识符</a></li>
<li><a href="#包引用"><span class="toc-section-number">1.2</span> 包引用</a></li>
</ul></li>
<li><a href="#数据类型"><span class="toc-section-number">2</span> 数据类型</a><ul>
<li><a href="#符号字面量"><span class="toc-section-number">2.1</span> 符号字面量</a></li>
<li><a href="#null值"><span class="toc-section-number">2.2</span> Null值</a></li>
</ul></li>
<li><a href="#变量"><span class="toc-section-number">3</span> 变量</a></li>
<li><a href="#访问修饰符"><span class="toc-section-number">4</span> 访问修饰符</a><ul>
<li><a href="#作用域保护"><span class="toc-section-number">4.1</span> 作用域保护</a></li>
</ul></li>
<li><a href="#运算符"><span class="toc-section-number">5</span> 运算符</a></li>
<li><a href="#ifelse"><span class="toc-section-number">6</span> IF…ELSE</a></li>
<li><a href="#循环"><span class="toc-section-number">7</span> 循环</a></li>
<li><a href="#函数"><span class="toc-section-number">8</span> 函数</a><ul>
<li><a href="#函数声明"><span class="toc-section-number">8.1</span> 函数声明</a></li>
<li><a href="#call-by-name"><span class="toc-section-number">8.2</span> call-by-name</a></li>
<li><a href="#可变参数"><span class="toc-section-number">8.3</span> 可变参数</a></li>
<li><a href="#偏函数"><span class="toc-section-number">8.4</span> 偏函数</a></li>
<li><a href="#高阶函数"><span class="toc-section-number">8.5</span> 高阶函数</a></li>
<li><a href="#匿名函数"><span class="toc-section-number">8.6</span> 匿名函数</a></li>
<li><a href="#currying-function"><span class="toc-section-number">8.7</span> Currying Function</a></li>
</ul></li>
<li><a href="#闭包"><span class="toc-section-number">9</span> 闭包</a></li>
<li><a href="#字符串"><span class="toc-section-number">10</span> 字符串</a><ul>
<li><a href="#格式化字符串"><span class="toc-section-number">10.1</span> 格式化字符串</a></li>
</ul></li>
<li><a href="#数组"><span class="toc-section-number">11</span> 数组</a><ul>
<li><a href="#多维数组"><span class="toc-section-number">11.1</span> 多维数组</a></li>
</ul></li>
<li><a href="#collection"><span class="toc-section-number">12</span> Collection</a><ul>
<li><a href="#list"><span class="toc-section-number">12.1</span> List</a><ul>
<li><a href="#基本操作"><span class="toc-section-number">12.1.1</span> 基本操作</a></li>
<li><a href="#链接列表"><span class="toc-section-number">12.1.2</span> 链接列表</a></li>
<li><a href="#list.tabulate"><span class="toc-section-number">12.1.3</span> List.tabulate()</a></li>
</ul></li>
<li><a href="#set"><span class="toc-section-number">12.2</span> Set</a><ul>
<li><a href="#基本操作-1"><span class="toc-section-number">12.2.1</span> 基本操作</a></li>
<li><a href="#连接"><span class="toc-section-number">12.2.2</span> 连接</a></li>
<li><a href="#交集"><span class="toc-section-number">12.2.3</span> 交集</a></li>
</ul></li>
<li><a href="#map"><span class="toc-section-number">12.3</span> Map</a><ul>
<li><a href="#合并"><span class="toc-section-number">12.3.1</span> 合并</a></li>
<li><a href="#输出map的keys和values"><span class="toc-section-number">12.3.2</span> 输出Map的keys和values</a></li>
</ul></li>
<li><a href="#元组"><span class="toc-section-number">12.4</span> 元组</a><ul>
<li><a href="#迭代"><span class="toc-section-number">12.4.1</span> 迭代</a></li>
</ul></li>
<li><a href="#option"><span class="toc-section-number">12.5</span> Option</a></li>
<li><a href="#iterator"><span class="toc-section-number">12.6</span> Iterator</a></li>
</ul></li>
<li><a href="#类和对象"><span class="toc-section-number">13</span> 类和对象</a><ul>
<li><a href="#继承"><span class="toc-section-number">13.1</span> 继承</a></li>
<li><a href="#单例对象"><span class="toc-section-number">13.2</span> 单例对象</a></li>
</ul></li>
<li><a href="#trait"><span class="toc-section-number">14</span> Trait</a><ul>
<li><a href="#特征构造顺序"><span class="toc-section-number">14.1</span> 特征构造顺序</a></li>
</ul></li>
<li><a href="#模式匹配"><span class="toc-section-number">15</span> 模式匹配</a><ul>
<li><a href="#使用样例类"><span class="toc-section-number">15.1</span> 使用样例类</a></li>
</ul></li>
<li><a href="#正则表达式"><span class="toc-section-number">16</span> 正则表达式</a></li>
<li><a href="#异常"><span class="toc-section-number">17</span> 异常</a><ul>
<li><a href="#捕获异常"><span class="toc-section-number">17.1</span> 捕获异常</a></li>
</ul></li>
<li><a href="#extractor"><span class="toc-section-number">18</span> Extractor</a><ul>
<li><a href="#提取器与模式匹配"><span class="toc-section-number">18.1</span> 提取器与模式匹配</a></li>
</ul></li>
<li><a href="#io"><span class="toc-section-number">19</span> IO</a><ul>
<li><a href="#文件中读取"><span class="toc-section-number">19.1</span> 文件中读取</a></li>
</ul></li>
<li><a href="#参考"><span class="toc-section-number">20</span> 参考</a></li>
</ul>
</nav>
<h1 id="基础语法"><span class="header-section-number">1</span> 基础语法</h1>
<h2 id="标识符"><span class="header-section-number">1.1</span> 标识符</h2>
<p>Scala 可以使用两种形式的标志符，字符数字和符号。字符数字使用字母或是下划线开头，后面可以接字母或是数字，符号“(”在 Scala 中也看作为字母。然而以“)”开头的标识符 为保留的 Scala 编译器产生的标志符使用，应用程序应该避免使用“$”开始的标识符，以免造成冲突。此外也应该避免使用以下划线结尾的标志符以避免冲突。符号标志符包含一个或多个符号，如 <code>+，:，?</code> 等。比如:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb1-1" title="1">    +、++、:::、&lt;、?&gt;、:-&gt;</a></code></pre></div>
<p>Scala 内部实现时会使用转义的标志符，比如 <code>:-&gt;</code> ; 使用 <code>$colon$minus$greater</code> 来表示这 个符号。因此如果你需要在 Java 代码中访问 <code>:-&gt;</code> 方法，你需要使用 Scala 的内部名称 <code>$colon$minus$greater</code> 。</p>
<h2 id="包引用"><span class="header-section-number">1.2</span> 包引用</h2>
<div class="sourceCode" id="cb2"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb2-1" title="1">    <span class="kw">import</span> java.<span class="fu">awt</span>.{Color, Font}</a>
<a class="sourceLine" id="cb2-2" title="2">    <span class="co">// 重命名成员</span></a>
<a class="sourceLine" id="cb2-3" title="3">    <span class="kw">import</span> java.<span class="fu">util</span>.{HashMap =&gt; JavaHashMap}</a>
<a class="sourceLine" id="cb2-4" title="4">    <span class="co">// 隐藏成员</span></a>
<a class="sourceLine" id="cb2-5" title="5">    <span class="kw">import</span> java.<span class="fu">util</span>.{HashMap =&gt; _, _} <span class="co">// 引入了util包的所有成员，但是HashMap被隐藏了</span></a></code></pre></div>
<p><strong>注意 1.</strong> 默认情况下，Scala 总会引入 <code>java.lang._</code> 、 <code>scala._</code> 和 <code>Predef._</code> ，这 里也能解释，为什么以scala开头的包，在使用时都是省去scala.的。</p>
<h1 id="数据类型"><span class="header-section-number">2</span> 数据类型</h1>
<ul>
<li>Unit：表示无值，和其他语言中void等同。用作不返回任何结果的方法的结果类型。Unit只有一个实例值，写成()；</li>
<li>Nothing：Nothing类型在Scala的类层级的最低端；它是任何其他类型的子类型；</li>
<li>Any：Any是所有其他类的超类；</li>
<li>AnyRef：AnyRef类是Scala里所有引用类(reference class)的基类</li>
</ul>
<h2 id="符号字面量"><span class="header-section-number">2.1</span> 符号字面量</h2>
<p>符号字面量被写成： <sub>’&lt;标识符&gt;</sub> ，这里 <code>&lt;标识符&gt;</code> 可以是任何字母或数字的标识（注意：不能以数字开头）。这种字面量被映射成预定义类scala.Symbol的实例。</p>
<p>如： 符号字面量 =’x= 是表达式 <code>scala.Symbol("x")</code> 的简写，符号字面量定义如下：</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb3-1" title="1">    <span class="kw">package</span> scala</a>
<a class="sourceLine" id="cb3-2" title="2">    <span class="kw">final</span> <span class="kw">case</span> <span class="kw">class</span> Symbol <span class="kw">private</span> (name: String) {</a>
<a class="sourceLine" id="cb3-3" title="3">        <span class="kw">override</span> <span class="kw">def</span> toString: String = <span class="st">&quot;&#39;&quot;</span> + name</a>
<a class="sourceLine" id="cb3-4" title="4">    }</a></code></pre></div>
<h2 id="null值"><span class="header-section-number">2.2</span> Null值</h2>
<p>空值是 scala.Null 类型。Scala.Null和scala.Nothing是用统一的方式处理Scala面向对象类型系统的某些“边界情况”的特殊类型。Null类是null引用对象的类型，它是每个引用类（继承自AnyRef的类）的子类。Null不兼容值类型。</p>
<h1 id="变量"><span class="header-section-number">3</span> 变量</h1>
<p>在 Scala 中，使用关键词 “var” 声明变量，使用关键词 “val” 声明常量。</p>
<p>Scala 支持多个变量的声明：</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb4-1" title="1">    <span class="kw">val</span> xmax, ymax = <span class="dv">100</span> <span class="co">// xmax, ymax都声明为100</span></a></code></pre></div>
<h1 id="访问修饰符"><span class="header-section-number">4</span> 访问修饰符</h1>
<p>Scala 访问修饰符基本和 Java 的一样，分别有：private，protected，public。如果没有指定访问修饰符符，默认情况下，Scala对象的访问级别都是 public。Scala 中的 private 限定符，比 Java 更严格，在嵌套类情况下，外层类甚至不能访问被嵌套类的私有成员。</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb5-1" title="1">    <span class="kw">class</span> Outer{</a>
<a class="sourceLine" id="cb5-2" title="2">        <span class="kw">class</span> Inner{</a>
<a class="sourceLine" id="cb5-3" title="3">            <span class="kw">private</span> <span class="kw">def</span> <span class="fu">f</span>(){<span class="fu">println</span>(<span class="st">&quot;f&quot;</span>)}</a>
<a class="sourceLine" id="cb5-4" title="4">            <span class="kw">class</span> InnerMost{</a>
<a class="sourceLine" id="cb5-5" title="5">                <span class="fu">f</span>() <span class="co">// 正确</span></a>
<a class="sourceLine" id="cb5-6" title="6">            }</a>
<a class="sourceLine" id="cb5-7" title="7">        }</a>
<a class="sourceLine" id="cb5-8" title="8">        (<span class="kw">new</span> Inner).<span class="fu">f</span>() <span class="co">//错误</span></a>
<a class="sourceLine" id="cb5-9" title="9">    }</a></code></pre></div>
<p>在 scala 中，对保护（Protected）成员的访问比 java 更严格一些。因为它只允许保护 成员在定义了该成员的的类的子类中被访问。</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb6-1" title="1">    <span class="kw">package</span> p{</a>
<a class="sourceLine" id="cb6-2" title="2">    <span class="kw">class</span> Super{</a>
<a class="sourceLine" id="cb6-3" title="3">        <span class="kw">protected</span> <span class="kw">def</span> <span class="fu">f</span>() {<span class="fu">println</span>(<span class="st">&quot;f&quot;</span>)}</a>
<a class="sourceLine" id="cb6-4" title="4">    }</a>
<a class="sourceLine" id="cb6-5" title="5"></a>
<a class="sourceLine" id="cb6-6" title="6">    <span class="kw">class</span> Sub <span class="kw">extends</span> Super{</a>
<a class="sourceLine" id="cb6-7" title="7">        <span class="fu">f</span>()</a>
<a class="sourceLine" id="cb6-8" title="8">    }</a>
<a class="sourceLine" id="cb6-9" title="9"></a>
<a class="sourceLine" id="cb6-10" title="10">    <span class="kw">class</span> Other {</a>
<a class="sourceLine" id="cb6-11" title="11">        (<span class="kw">new</span> Super).<span class="fu">f</span>() <span class="co">//错误</span></a>
<a class="sourceLine" id="cb6-12" title="12">    }</a>
<a class="sourceLine" id="cb6-13" title="13">    }</a></code></pre></div>
<p>Scala中，如果没有指定任何的修饰符，则默认为 public。这样的成员在任何地方都可以被访问。</p>
<h2 id="作用域保护"><span class="header-section-number">4.1</span> 作用域保护</h2>
<p>Scala中，访问修饰符可以通过使用限定词强调。格式为:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb7-1" title="1">    <span class="kw">private</span>[x]</a></code></pre></div>
<p>或</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb8-1" title="1">    <span class="kw">protected</span>[x]</a></code></pre></div>
<p>这里的x指代某个所属的包、类或单例对象。如果写成 <code>private[x]</code>,读作"这个成员除了对[…]中的类或[…]中的包中的类及它们的伴生对像可见外，对其它所有类都是private。</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb9-1" title="1">    <span class="kw">package</span> bobsrocckets{</a>
<a class="sourceLine" id="cb9-2" title="2">        <span class="kw">package</span> navigation{</a>
<a class="sourceLine" id="cb9-3" title="3">            <span class="kw">private</span>[bobsrockets] <span class="kw">class</span> Navigator{</a>
<a class="sourceLine" id="cb9-4" title="4">                <span class="kw">protected</span>[navigation] <span class="kw">def</span> <span class="fu">useStarChart</span>(){}</a>
<a class="sourceLine" id="cb9-5" title="5">                <span class="kw">class</span> LegOfJourney{</a>
<a class="sourceLine" id="cb9-6" title="6">                    <span class="kw">private</span>[Navigator] <span class="kw">val</span> distance = <span class="dv">100</span></a>
<a class="sourceLine" id="cb9-7" title="7">                }</a>
<a class="sourceLine" id="cb9-8" title="8">                <span class="kw">private</span>[<span class="kw">this</span>] <span class="kw">var</span> speed = <span class="dv">200</span></a>
<a class="sourceLine" id="cb9-9" title="9">            }</a>
<a class="sourceLine" id="cb9-10" title="10">        <span class="kw">package</span> launch{</a>
<a class="sourceLine" id="cb9-11" title="11">            <span class="kw">import</span> navigation.</a>
<a class="sourceLine" id="cb9-12" title="12">            <span class="kw">object</span> Vehicle{</a>
<a class="sourceLine" id="cb9-13" title="13">                <span class="kw">private</span>[launch] <span class="kw">val</span> guide = <span class="kw">new</span> Navigator</a>
<a class="sourceLine" id="cb9-14" title="14">            }</a>
<a class="sourceLine" id="cb9-15" title="15">        }</a>
<a class="sourceLine" id="cb9-16" title="16">    }</a></code></pre></div>
<p>上述例子中，类 <code>Navigator</code> 被标记为 <code>private[bobsrockets]</code> 就是说这个类对包含在 bobsrockets包里的所有的类和对象可见。</p>
<p>比如说，从Vehicle对象里对Navigator的访问是被允许的，因为对象Vehicle包含在包 launch 中，而 launch 包在 bobsrockets 中，相反，所有在包 bobsrockets 之外的代码都不能访问类 Navigator。</p>
<h1 id="运算符"><span class="header-section-number">5</span> 运算符</h1>
<h1 id="ifelse"><span class="header-section-number">6</span> IF…ELSE</h1>
<h1 id="循环"><span class="header-section-number">7</span> 循环</h1>
<h1 id="函数"><span class="header-section-number">8</span> 函数</h1>
<p>Scala 有函数和方法，二者在语义上的区别很小。Scala 方法是类的一部分，而函数是一个对象可以赋值给一个变量。换句话来说在类中定义的函数即是方法。更重要的一点是 Scala 函数名可以有以下特殊字符： <code>**+, ++, ~, &amp;,-, –- , \, /, :</code> 等。</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb10-1" title="1">    <span class="kw">object</span> add{</a>
<a class="sourceLine" id="cb10-2" title="2">        <span class="kw">def</span> <span class="fu">addInt</span>( a:Int, b:Int ) : Int = {</a>
<a class="sourceLine" id="cb10-3" title="3">            <span class="kw">var</span> sum:Int = <span class="dv">0</span></a>
<a class="sourceLine" id="cb10-4" title="4">            sum = a + b</a>
<a class="sourceLine" id="cb10-5" title="5">           <span class="kw">return</span> sum</a>
<a class="sourceLine" id="cb10-6" title="6">        }</a>
<a class="sourceLine" id="cb10-7" title="7">    }</a></code></pre></div>
<h2 id="函数声明"><span class="header-section-number">8.1</span> 函数声明</h2>
<div class="sourceCode" id="cb11"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb11-1" title="1">    <span class="kw">def</span> <span class="fu">functionName</span> ([参数列表]) : [<span class="kw">return</span> <span class="kw">type</span>]</a></code></pre></div>
<p>如果你不写等于号和方法主体，那么方法会被隐式声明为“抽象(abstract)”，包含它的类型于是也是一个抽象类型。</p>
<h2 id="call-by-name"><span class="header-section-number">8.2</span> call-by-name</h2>
<p>Scala的解释器在解析函数参数(function arguments)时有两种方式：</p>
<ul>
<li>传值调用（call-by-value）：先计算参数表达式的值，再应用到函数内部；</li>
<li>传名调用（call-by-name）：将未计算的参数表达式直接应用到函数内部</li>
</ul>
<p>在进入函数内部前，传值调用方式就已经将参数表达式的值计算完毕，而传名调用是在函数内部进行参数表达式的值计算的。这就造成了一种现象，每次使用传名调用时，解释器都会计算一次表达式的值。</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb12-1" title="1">    <span class="kw">object</span> Test {</a>
<a class="sourceLine" id="cb12-2" title="2">        <span class="kw">def</span> <span class="fu">main</span>(args: Array[String]) {</a>
<a class="sourceLine" id="cb12-3" title="3">            <span class="fu">delayed</span>(<span class="fu">time</span>());</a>
<a class="sourceLine" id="cb12-4" title="4">        }</a>
<a class="sourceLine" id="cb12-5" title="5">        <span class="kw">def</span> <span class="fu">time</span>() = {</a>
<a class="sourceLine" id="cb12-6" title="6">            <span class="fu">println</span>(<span class="st">&quot;获取时间，单位为纳秒&quot;</span>)</a>
<a class="sourceLine" id="cb12-7" title="7">            System.<span class="fu">nanoTime</span></a>
<a class="sourceLine" id="cb12-8" title="8">        }</a>
<a class="sourceLine" id="cb12-9" title="9">        <span class="kw">def</span> <span class="fu">delayed</span>( t: =&gt; Long ) = {</a>
<a class="sourceLine" id="cb12-10" title="10">            <span class="fu">println</span>(<span class="st">&quot;在 delayed 方法内&quot;</span>)</a>
<a class="sourceLine" id="cb12-11" title="11">            <span class="fu">println</span>(<span class="st">&quot;参数： &quot;</span> + t)</a>
<a class="sourceLine" id="cb12-12" title="12">            t</a>
<a class="sourceLine" id="cb12-13" title="13">        }</a>
<a class="sourceLine" id="cb12-14" title="14">    }</a></code></pre></div>
<h2 id="可变参数"><span class="header-section-number">8.3</span> 可变参数</h2>
<p>见示例VariableParam.scala</p>
<h2 id="偏函数"><span class="header-section-number">8.4</span> 偏函数</h2>
<p>Scala 偏应用函数是一种表达式，你不需要提供函数需要的所有参数，只需要提供部分，或不提供所需参数。</p>
<p>见示例PartialFunc.scala</p>
<h2 id="高阶函数"><span class="header-section-number">8.5</span> 高阶函数</h2>
<p>见示例HigherOrderFunc.scala</p>
<h2 id="匿名函数"><span class="header-section-number">8.6</span> 匿名函数</h2>
<div class="sourceCode" id="cb13"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb13-1" title="1">    <span class="kw">var</span> inc = (x:Int) =&gt; x+<span class="dv">1</span></a>
<a class="sourceLine" id="cb13-2" title="2">    <span class="kw">var</span> mul = (x: Int, y: Int) =&gt; x*y</a>
<a class="sourceLine" id="cb13-3" title="3">    <span class="kw">var</span> userDir = () =&gt; { System.<span class="fu">getProperty</span>(<span class="st">&quot;user.dir&quot;</span>) }</a></code></pre></div>
<h2 id="currying-function"><span class="header-section-number">8.7</span> Currying Function</h2>
<p>柯里化(Currying)指的是将原来接受两个参数的函数变成新的接受一个参数的函数的过程。新的函数返回一个以原有第二个参数为参数的函数。</p>
<p>见示例CurryingFunc.scala</p>
<h1 id="闭包"><span class="header-section-number">9</span> 闭包</h1>
<h1 id="字符串"><span class="header-section-number">10</span> 字符串</h1>
<h2 id="格式化字符串"><span class="header-section-number">10.1</span> 格式化字符串</h2>
<p>String 类中你可以使用 printf() 方法来格式化字符串并输出，String format() 方法可 以返回 String 对象而不是 PrintStream 对象。以下实例演示了 printf() 方法的使用：</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb14-1" title="1">    <span class="kw">object</span> Test {</a>
<a class="sourceLine" id="cb14-2" title="2">        <span class="kw">def</span> <span class="fu">main</span>(args: Array[String]) {</a>
<a class="sourceLine" id="cb14-3" title="3">            <span class="kw">var</span> floatVar = <span class="fl">12.456</span></a>
<a class="sourceLine" id="cb14-4" title="4">            <span class="kw">var</span> intVar = <span class="dv">2000</span></a>
<a class="sourceLine" id="cb14-5" title="5">            <span class="kw">var</span> stringVar = <span class="st">&quot;StringVar!&quot;</span></a>
<a class="sourceLine" id="cb14-6" title="6">            <span class="kw">var</span> fs = <span class="fu">printf</span>(<span class="st">&quot;浮点型变量为 &quot;</span> +</a>
<a class="sourceLine" id="cb14-7" title="7">                            <span class="st">&quot;%f, 整型变量为 %d, 字符串为 &quot;</span> +</a>
<a class="sourceLine" id="cb14-8" title="8">                            floatVar, intVar, stringVar)</a>
<a class="sourceLine" id="cb14-9" title="9">            <span class="fu">println</span>(fs)</a>
<a class="sourceLine" id="cb14-10" title="10">        }</a>
<a class="sourceLine" id="cb14-11" title="11">    }</a></code></pre></div>
<p>见示例FormatString.scala</p>
<h1 id="数组"><span class="header-section-number">11</span> 数组</h1>
<h2 id="多维数组"><span class="header-section-number">11.1</span> 多维数组</h2>
<p>多维数组一个数组中的值可以是另一个数组，另一个数组的值也可以是一个数组。矩阵与表格是我们常见的二维数组。</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb15-1" title="1">    <span class="kw">var</span> myMatrix = ofDim[Int](<span class="dv">3</span>,<span class="dv">3</span>)</a></code></pre></div>
<p>见示例DimArray.scala</p>
<h1 id="collection"><span class="header-section-number">12</span> Collection</h1>
<p>Scala 集合分为可变的和不可变的集合。可变集合可以在适当的地方被更新或扩展。这意味着你可以修改，添加，移除一个集合的元素。而不可变集合类，相比之下，永远不会改变。不过，你仍然可以模拟添加，移除或更新操作。但是这些操作将在每一种情况下都返回一个新的集合，同时使原来的集合不发生改变。</p>
<h2 id="list"><span class="header-section-number">12.1</span> List</h2>
<p>Scala 列表类似于数组，它们所有元素的类型都相同，但是它们也有所不同：列表是不可变的，值一旦被定义了就不能改变，其次列表具有递归的结构（也就是链接表结构）而数组不是。</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb16-1" title="1">    <span class="co">// 空列表</span></a>
<a class="sourceLine" id="cb16-2" title="2">    <span class="kw">val</span> empty List[Nothing] = List()</a>
<a class="sourceLine" id="cb16-3" title="3"></a>
<a class="sourceLine" id="cb16-4" title="4">    <span class="co">// 二维列表</span></a>
<a class="sourceLine" id="cb16-5" title="5">    <span class="kw">val</span> dim: List[List[Int]] =</a>
<a class="sourceLine" id="cb16-6" title="6">        List(</a>
<a class="sourceLine" id="cb16-7" title="7">            List(<span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span>),</a>
<a class="sourceLine" id="cb16-8" title="8">            List(<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">0</span>),</a>
<a class="sourceLine" id="cb16-9" title="9">            List(<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb16-10" title="10">        )</a></code></pre></div>
<h3 id="基本操作"><span class="header-section-number">12.1.1</span> 基本操作</h3>
<p>Scala列表有三个基本操作：</p>
<ul>
<li><code>head</code> 返回列表第一个元素</li>
<li><code>tail</code> 返回一个列表，包含除了第一元素之外的其他元素</li>
<li><code>isEmpty</code> 在列表为空时返回true</li>
</ul>
<h3 id="链接列表"><span class="header-section-number">12.1.2</span> 链接列表</h3>
<p>你可以使用 <code>:::</code> 运算符或 <code>List.:::()</code> 方法或 <code>**List.concat()</code> 方法来连接两个或多个 列表，示例见ConcatList.scala</p>
<h3 id="list.tabulate"><span class="header-section-number">12.1.3</span> List.tabulate()</h3>
<p>List.tabulate() 方法是通过给定的函数来创建列表。方法的第一个参数为元素的数量，可以是二维的，第二个参数为指定的函数，我们通过指定的函数计算结果并返回值插入到列表中，起始值为0。</p>
<h2 id="set"><span class="header-section-number">12.2</span> Set</h2>
<p>Scala Set(集合)是没有重复的对象集合，所有的元素都是唯一的。Scala 集合分为可变的和 不可变的集合。默认情况下，Scala 使用的是不可变集合，如果你想使用可变集合，需要引用 <code>scala.collection.mutable.Set</code> 包。默认引用 <code>scala.collection.immutable.Set</code> ，不可 变集合实例如下：</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb17-1" title="1">    <span class="kw">val</span> set = Set(<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>)</a>
<a class="sourceLine" id="cb17-2" title="2">    <span class="fu">println</span>(set.<span class="fu">getClass</span>.<span class="fu">getName</span>) <span class="co">// </span></a>
<a class="sourceLine" id="cb17-3" title="3">    <span class="fu">println</span>(set.<span class="fu">exists</span>(_ % <span class="dv">2</span> == <span class="dv">0</span>)) <span class="co">//true</span></a>
<a class="sourceLine" id="cb17-4" title="4">    <span class="fu">println</span>(set.<span class="fu">drop</span>(<span class="dv">1</span>)) <span class="co">//Set(2,3)</span></a></code></pre></div>
<p><strong>注意 2.</strong>: 虽然可变Set和不可变Set都有添加或删除元素的操作，但是有一个非常大的差别。对不可变Set进行操作，会产生一个新的set，原来的set并没有改变，这与List一样。而对可变Set进行操作，改变的是该Set本身，与ListBuffer类似。</p>
<h3 id="基本操作-1"><span class="header-section-number">12.2.1</span> 基本操作</h3>
<p>Scala集合有三个基本操作：</p>
<ul>
<li><code>head</code> 返回集合第一个元素</li>
<li><code>tail</code> 返回一个集合，包含除了第一元素之外的其他元素</li>
<li><code>isEmpty</code> 在集合为空时返回true</li>
</ul>
<h3 id="连接"><span class="header-section-number">12.2.2</span> 连接</h3>
<p>你可以使用 <code>++</code> 运算符或 <code>Set.++()</code> 方法来连接两个集合。如果元素有重复的就会移除 重复的元素。</p>
<h3 id="交集"><span class="header-section-number">12.2.3</span> 交集</h3>
<p>你可以使用 <code>Set.&amp;</code> 方法或 <code>Set.intersect</code> 方法来查看两个集合的交集元素。</p>
<h2 id="map"><span class="header-section-number">12.3</span> Map</h2>
<p>Map 有两种类型，可变与不可变，区别在于可变对象可以修改它，而不可变对象不可以。默认情况下 Scala 使用不可变 Map。如果你需要使用可变集合，你需要显式的引入 <code>import scala.collection.mutable.Map</code> 类。在 Scala 中你可以同时使用可变与不可变 Map， 不可变的直接使用 Map，可变的使用 mutable.Map。</p>
<h3 id="合并"><span class="header-section-number">12.3.1</span> 合并</h3>
<p>你可以使用 <code>++</code> 运算符或 <code>Map.++()</code> 方法来连接两个 Map，Map 合并时会移除重复的 key。</p>
<h3 id="输出map的keys和values"><span class="header-section-number">12.3.2</span> 输出Map的keys和values</h3>
<div class="sourceCode" id="cb18"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb18-1" title="1">    <span class="kw">object</span> Test {</a>
<a class="sourceLine" id="cb18-2" title="2">        <span class="kw">def</span> <span class="fu">main</span>(args: Array[String]) {</a>
<a class="sourceLine" id="cb18-3" title="3">            <span class="kw">val</span> sites = Map(<span class="st">&quot;runoob&#39;&#39; -&gt; ‘‘http://www.runoob.com&quot;</span>,</a>
<a class="sourceLine" id="cb18-4" title="4">                            <span class="st">&quot;baidu&#39;&#39; -&gt; ‘‘http://www.baidu.com&quot;</span>,</a>
<a class="sourceLine" id="cb18-5" title="5">                            <span class="st">&quot;taobao&#39;&#39; -&gt; ‘‘http://www.taobao.com&quot;</span>)</a>
<a class="sourceLine" id="cb18-6" title="6">            sites.<span class="fu">keys</span>.<span class="fu">foreach</span>{ i =&gt;</a>
<a class="sourceLine" id="cb18-7" title="7">                                <span class="fu">print</span>( ‘‘Key = &#39;&#39; + i )</a>
<a class="sourceLine" id="cb18-8" title="8">                                <span class="fu">println</span>(&#39;&#39; Value = &#39;&#39; + <span class="fu">sites</span>(i) )}</a>
<a class="sourceLine" id="cb18-9" title="9">        }</a>
<a class="sourceLine" id="cb18-10" title="10">    }</a></code></pre></div>
<h2 id="元组"><span class="header-section-number">12.4</span> 元组</h2>
<p>与列表一样，元组也是不可变的，但与列表不同的是元组可以包含不同类型的元素。目前 Scala 支持的元组最大长度为 22。对于更大长度你可以使用集合，或者扩展元组。</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb19-1" title="1">    <span class="kw">object</span> Test {</a>
<a class="sourceLine" id="cb19-2" title="2">        <span class="kw">def</span> <span class="fu">main</span>(args: Array[String]) {</a>
<a class="sourceLine" id="cb19-3" title="3">          <span class="kw">val</span> t = (<span class="dv">4</span>,<span class="dv">3</span>,<span class="dv">2</span>,<span class="dv">1</span>)</a>
<a class="sourceLine" id="cb19-4" title="4">          <span class="kw">val</span> sum = t._<span class="dv">1</span> + t._<span class="dv">2</span> + t._<span class="dv">3</span> + t._<span class="dv">4</span></a>
<a class="sourceLine" id="cb19-5" title="5">          <span class="fu">println</span>( <span class="st">&quot;元素之和为: &quot;</span> + sum ) </a>
<a class="sourceLine" id="cb19-6" title="6">        }</a>
<a class="sourceLine" id="cb19-7" title="7">    }</a></code></pre></div>
<h3 id="迭代"><span class="header-section-number">12.4.1</span> 迭代</h3>
<div class="sourceCode" id="cb20"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb20-1" title="1">    <span class="kw">object</span> Test {</a>
<a class="sourceLine" id="cb20-2" title="2">        <span class="kw">def</span> <span class="fu">main</span>(args: Array[String]) {</a>
<a class="sourceLine" id="cb20-3" title="3">          <span class="kw">val</span> t = (<span class="dv">4</span>,<span class="dv">3</span>,<span class="dv">2</span>,<span class="dv">1</span>)</a>
<a class="sourceLine" id="cb20-4" title="4">          t.<span class="fu">productIterator</span>.<span class="fu">foreach</span>{ i =&gt;<span class="fu">println</span>(<span class="st">&quot;Value = &quot;</span> + i )}</a>
<a class="sourceLine" id="cb20-5" title="5">        }</a>
<a class="sourceLine" id="cb20-6" title="6">    }</a></code></pre></div>
<h2 id="option"><span class="header-section-number">12.5</span> Option</h2>
<p>Scala Option(选项)类型用来表示一个值是可选的（有值或无值)。Option[T] 是一个类型为 T 的可选值的容器： 如果值存在， Option[T] 就是一个 Some[T] ，如果不存在， Option[T] 就是对象 None 。</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb21-1" title="1">    <span class="kw">val</span> myMap: Map[String, String] = Map(<span class="st">&quot;key1&quot;</span> -&gt; <span class="st">&quot;value&quot;</span>)</a>
<a class="sourceLine" id="cb21-2" title="2">    <span class="kw">val</span> value1: Option[String] = myMap.<span class="fu">get</span>(<span class="st">&quot;key1&quot;</span>)</a>
<a class="sourceLine" id="cb21-3" title="3">    <span class="kw">val</span> value2: Option[String] = myMap.<span class="fu">get</span>(<span class="st">&quot;key2&quot;</span>)</a></code></pre></div>
<p>参见示例OptionTest.scala</p>
<h2 id="iterator"><span class="header-section-number">12.6</span> Iterator</h2>
<p>见示例IteratorTest.scala</p>
<h1 id="类和对象"><span class="header-section-number">13</span> 类和对象</h1>
<h2 id="继承"><span class="header-section-number">13.1</span> 继承</h2>
<p>Scala继承一个基类跟Java很相似, 但我们需要注意以下几点：</p>
<ul>
<li>重写一个非抽象方法必须使用override修饰符。</li>
<li>只有主构造函数才可以往基类的构造函数里写参数。</li>
<li>在子类中重写超类的抽象方法时，你不需要使用override关键字。</li>
</ul>
<h2 id="单例对象"><span class="header-section-number">13.2</span> 单例对象</h2>
<p>在 Scala 中，是没有 static 这个东西的，但是它也为我们提供了单例模式的实现方法， 那就是使用关键字 object。Scala 中使用单例模式时，除了定义的类之外，还要定义一个同名的 object 对象，它和类的区别是，object对象不能带参数。</p>
<p>当单例对象与某个类共享同一个名称时，他被称作是这个类的伴生对象：companion object。你必须在同一个源文件里定义类和它的伴生对象。类被称为是这个单例对象的伴生类：companion class。类和它的伴生对象可以互相访问其私有成员。</p>
<p>见示例CompanionClass.scala</p>
<h1 id="trait"><span class="header-section-number">14</span> Trait</h1>
<p>Scala Trait(特征) 相当于 Java 的接口，实际上它比接口还功能强大。与接口不同的是，它还可以定义属性和方法的实现。一般情况下Scala的类只能够继承单一父类，但是如果是 Trait(特征) 的话就可以继承多个，从结果来看就是实现了多重继承。</p>
<h2 id="特征构造顺序"><span class="header-section-number">14.1</span> 特征构造顺序</h2>
<p>特征也可以有构造器，由字段的初始化和其他特征体中的语句构成。这些语句在任何混入该特征的对象在构造是都会被执行。</p>
<p>构造器的执行顺序：</p>
<ul>
<li>调用超类的构造器；</li>
<li>特征构造器在超类构造器之后、类构造器之前执行；</li>
<li>特征由左到右被构造；</li>
<li>每个特征当中，父特征先被构造；</li>
<li>如果多个特征共有一个父特征，父特征不会被重复构造</li>
<li>所有特征被构造完毕，子类被构造。</li>
</ul>
<p>构造器的顺序是类的线性化的反向。线性化是描述某个类型的所有超类型的一种技术规格。</p>
<h1 id="模式匹配"><span class="header-section-number">15</span> 模式匹配</h1>
<p>见示例MatchTest.scala</p>
<h2 id="使用样例类"><span class="header-section-number">15.1</span> 使用样例类</h2>
<p>使用了case关键字的类定义就是就是样例类(case classes)，样例类是种特殊的类， 经过优化以用于模式匹配。</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb22-1" title="1">    <span class="kw">object</span> Test {</a>
<a class="sourceLine" id="cb22-2" title="2">      <span class="kw">def</span> <span class="fu">main</span>(args: Array[String]) {</a>
<a class="sourceLine" id="cb22-3" title="3">        <span class="kw">val</span> alice = <span class="kw">new</span> <span class="fu">Person</span>(<span class="st">&quot;Alice&quot;</span>, <span class="dv">25</span>)</a>
<a class="sourceLine" id="cb22-4" title="4">        <span class="kw">val</span> bob = <span class="kw">new</span> <span class="fu">Person</span>(<span class="st">&quot;Bob&quot;</span>, <span class="dv">32</span>)</a>
<a class="sourceLine" id="cb22-5" title="5">        <span class="kw">val</span> charlie = <span class="kw">new</span> <span class="fu">Person</span>(<span class="st">&quot;Charlie&quot;</span>, <span class="dv">32</span>)</a>
<a class="sourceLine" id="cb22-6" title="6">        <span class="kw">for</span> (person &lt;- List(alice, bob, charlie)) {</a>
<a class="sourceLine" id="cb22-7" title="7">          person <span class="kw">match</span> {</a>
<a class="sourceLine" id="cb22-8" title="8">          <span class="kw">case</span> <span class="fu">Person</span>(<span class="st">&quot;Alice&quot;</span>, <span class="dv">25</span>) =&gt; <span class="fu">println</span>(<span class="st">&quot;Hi Alice!&quot;</span>)</a>
<a class="sourceLine" id="cb22-9" title="9">          <span class="kw">case</span> <span class="fu">Person</span>(<span class="st">&quot;Bob&quot;</span>, <span class="dv">32</span>) =&gt; <span class="fu">println</span>(<span class="st">&quot;Hi Bob!&quot;</span>)</a>
<a class="sourceLine" id="cb22-10" title="10">          <span class="kw">case</span> <span class="fu">Person</span>(name, age) =&gt; <span class="fu">println</span>(<span class="st">&quot;Age: &quot;</span> + age + <span class="st">&quot; year, name: &quot;</span> + name + <span class="st">&quot;?&quot;</span>)</a>
<a class="sourceLine" id="cb22-11" title="11">          }</a>
<a class="sourceLine" id="cb22-12" title="12">        }</a>
<a class="sourceLine" id="cb22-13" title="13">      }  </a>
<a class="sourceLine" id="cb22-14" title="14">      <span class="co">// 样例类 </span></a>
<a class="sourceLine" id="cb22-15" title="15">      <span class="kw">case</span> <span class="kw">class</span> <span class="fu">Person</span>(name: String, age: Int)</a>
<a class="sourceLine" id="cb22-16" title="16">    }</a></code></pre></div>
<p>在声明样例类时，下面的过程自动发生了：</p>
<ul>
<li>构造器的每个参数都成为val，除非显式被声明为var，但是并不推荐这么做；</li>
<li>在伴生对象中提供了apply方法，所以可以不使用new关键字就可构建对象；</li>
<li>提供unapply方法使模式匹配可以工作；</li>
<li>生成toString、equals、hashCode和copy方法，除非显示给出这些方法的定义。</li>
</ul>
<h1 id="正则表达式"><span class="header-section-number">16</span> 正则表达式</h1>
<p>见示例RegexTest.scala</p>
<h1 id="异常"><span class="header-section-number">17</span> 异常</h1>
<h2 id="捕获异常"><span class="header-section-number">17.1</span> 捕获异常</h2>
<p>异常捕捉的机制与其他语言中一样，如果有异常发生，catch字句是按次序捕捉的。因此，在catch字句中，越具体的异常越要靠前，越普遍的异常越靠后。如果抛出的异常不在catch 字句中，该异常则无法处理，会被升级到调用者处。</p>
<h1 id="extractor"><span class="header-section-number">18</span> Extractor</h1>
<p>提取器是从传递给它的对象中提取出构造该对象的参数。Scala 标准库包含了一些预定义的 提取器，我们会大致的了解一下它们。Scala 提取器是一个带有unapply方法的对象。unapply 方法算是apply方法的反向操作：unapply接受一个对象，然后从对象中提取值，提取的值通常是用来构造该对象的值。</p>
<h2 id="提取器与模式匹配"><span class="header-section-number">18.1</span> 提取器与模式匹配</h2>
<p>在我们实例化一个类的时，可以带上0个或者多个的参数，编译器在实例化的时会调用 apply 方法。我们可以在类和对象中都定义 apply 方法。</p>
<p>就像我们之前提到过的，unapply 用于提取我们指定查找的值，它与 apply 的操作相反。 当我们在提取器对象中使用 match 语句是，unapply 将自动执行，如下所示：</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb23-1" title="1">    <span class="kw">object</span> Test {</a>
<a class="sourceLine" id="cb23-2" title="2">      <span class="kw">def</span> <span class="fu">main</span>(args: Array[String]) {</a>
<a class="sourceLine" id="cb23-3" title="3">        <span class="kw">val</span> x = <span class="fu">Test</span>(<span class="dv">5</span>)</a>
<a class="sourceLine" id="cb23-4" title="4">        <span class="fu">println</span>(x)</a>
<a class="sourceLine" id="cb23-5" title="5">        x <span class="kw">match</span> {</a>
<a class="sourceLine" id="cb23-6" title="6">        <span class="kw">case</span> <span class="fu">Test</span>(num) =&gt; <span class="fu">println</span>(x + <span class="st">&quot;是 &quot;</span> + num + <span class="st">&quot;的两倍！&quot;</span>)</a>
<a class="sourceLine" id="cb23-7" title="7">        <span class="co">//unapply 被调用</span></a>
<a class="sourceLine" id="cb23-8" title="8">        <span class="kw">case</span> _ =&gt; <span class="fu">println</span>(<span class="st">&quot;无法计算&quot;</span>)</a>
<a class="sourceLine" id="cb23-9" title="9">        }</a>
<a class="sourceLine" id="cb23-10" title="10">      }</a>
<a class="sourceLine" id="cb23-11" title="11">      <span class="kw">def</span> <span class="fu">apply</span>(x: Int) = x*<span class="dv">2</span></a>
<a class="sourceLine" id="cb23-12" title="12">      <span class="kw">def</span> <span class="fu">unapply</span>(z: Int): Option[Int] = <span class="kw">if</span> (z%<span class="dv">2</span>==<span class="dv">0</span>) Some(z/<span class="dv">2</span>) <span class="kw">else</span> None</a>
<a class="sourceLine" id="cb23-13" title="13">    }</a></code></pre></div>
<h1 id="io"><span class="header-section-number">19</span> IO</h1>
<div class="sourceCode" id="cb24"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb24-1" title="1">    <span class="kw">import</span> java.<span class="fu">io</span>._</a>
<a class="sourceLine" id="cb24-2" title="2"></a>
<a class="sourceLine" id="cb24-3" title="3">    <span class="kw">object</span> Test {</a>
<a class="sourceLine" id="cb24-4" title="4">      <span class="kw">def</span> <span class="fu">main</span>(args: Array[String]) {</a>
<a class="sourceLine" id="cb24-5" title="5">        <span class="kw">val</span> writer = <span class="kw">new</span> PrintWriter(<span class="kw">new</span> File(<span class="st">&quot;test.txt&quot;</span>))</a>
<a class="sourceLine" id="cb24-6" title="6">        writer.<span class="fu">write</span>(<span class="st">&quot;菜鸟教程&quot;</span>)</a>
<a class="sourceLine" id="cb24-7" title="7">        writer.<span class="fu">close</span>()</a>
<a class="sourceLine" id="cb24-8" title="8">      }</a>
<a class="sourceLine" id="cb24-9" title="9">    }</a></code></pre></div>
<h2 id="文件中读取"><span class="header-section-number">19.1</span> 文件中读取</h2>
<div class="sourceCode" id="cb25"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb25-1" title="1">    <span class="kw">import</span> scala.<span class="fu">io</span>.<span class="fu">Source</span></a>
<a class="sourceLine" id="cb25-2" title="2">    <span class="kw">object</span> Test {</a>
<a class="sourceLine" id="cb25-3" title="3">      <span class="kw">def</span> <span class="fu">main</span>(args: Array[String]) {</a>
<a class="sourceLine" id="cb25-4" title="4">          <span class="fu">println</span>(<span class="st">&quot;文件内容为:&quot;</span>)</a>
<a class="sourceLine" id="cb25-5" title="5">          Source.<span class="fu">fromFile</span>(<span class="st">&quot;test.txt&quot;</span>).<span class="fu">foreach</span>{</a>
<a class="sourceLine" id="cb25-6" title="6">            print</a>
<a class="sourceLine" id="cb25-7" title="7">          }</a>
<a class="sourceLine" id="cb25-8" title="8">      }</a>
<a class="sourceLine" id="cb25-9" title="9">    }</a></code></pre></div>
<h1 id="参考"><span class="header-section-number">20</span> 参考</h1>
<ul>
<li><a href="http://www.runoob.com/scala/scala-tutorial.html">Scala教程</a></li>
</ul>
</body>
</html>
