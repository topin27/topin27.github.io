<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>神经网络</title>
  <style>
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <link rel="stylesheet" href="/static/custom.css" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-AMS_CHTML-full" type="text/javascript"></script>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header id="title-block-header">
<h1 class="title">神经网络</h1>
</header>
<nav id="TOC" role="doc-toc">
<ul>
<li><a href="#模型"><span class="toc-section-number">1</span> 模型</a><ul>
<li><a href="#m-p神经元模型"><span class="toc-section-number">1.1</span> M-P神经元模型</a></li>
<li><a href="#感知机"><span class="toc-section-number">1.2</span> 感知机</a></li>
<li><a href="#多层神经网络"><span class="toc-section-number">1.3</span> 多层神经网络</a></li>
<li><a href="#多层感知机mlp"><span class="toc-section-number">1.4</span> 多层感知机（MLP）</a></li>
<li><a href="#dnn"><span class="toc-section-number">1.5</span> DNN</a></li>
<li><a href="#rnnrecurrent"><span class="toc-section-number">1.6</span> RNN（Recurrent）</a><ul>
<li><a href="#经典rnn"><span class="toc-section-number">1.6.1</span> 经典RNN</a></li>
<li><a href="#bi-rnn"><span class="toc-section-number">1.6.2</span> Bi-RNN</a></li>
<li><a href="#lstm"><span class="toc-section-number">1.6.3</span> LSTM</a></li>
<li><a href="#gru"><span class="toc-section-number">1.6.4</span> GRU</a></li>
<li><a href="#attention机制"><span class="toc-section-number">1.6.5</span> Attention机制</a></li>
<li><a href="#tdnn时延神经网络"><span class="toc-section-number">1.6.6</span> TDNN（时延神经网络）</a></li>
</ul></li>
<li><a href="#cnn"><span class="toc-section-number">1.7</span> CNN</a></li>
</ul></li>
<li><a href="#学习算法"><span class="toc-section-number">2</span> 学习算法</a><ul>
<li><a href="#gan"><span class="toc-section-number">2.1</span> GAN</a></li>
</ul></li>
<li><a href="#参考"><span class="toc-section-number">3</span> 参考</a></li>
</ul>
</nav>
<h1 id="模型"><span class="header-section-number">1</span> 模型</h1>
<h2 id="m-p神经元模型"><span class="header-section-number">1.1</span> M-P神经元模型</h2>
<p>典型的<a href="https://en.wikipedia.org/wiki/Artificial_neuron">M-P神经元模型</a> 的输出为：<span class="math display">\[y=f(∑/{i=1}^n{w/{i}x_i-*θ*})\]</span> 其中 <span class="math inline">\(θ\)</span> 为阈值，<span class="math inline">\(x_i\)</span>为第i个神经元的输入，<span class="math inline">\(w_i\)</span>为第i个神经元的输入的权重。通常也会表示为<span class="math inline">\(z=∑*w*_*i**x*_*i* + *b*\)</span>且<span class="math inline">\(y=*σ*(*z*)\)</span></p>
<p>激活函数f可以通过(∑/{i=1}^n{w/{i}x_i})与阈值比较，如果大于阈值则输出1，否则输出0（或者-1）。理想的激活函数是<a href="https://en.wikipedia.org/wiki/Sign_function">阶跃函数</a> ，但是由于阶跃函数不连续且不光滑，因此实际上会用<a href="https://en.wikipedia.org/wiki/Sigmoid_function">sigmoid函数</a> 作为激活函数。</p>
<p>多个神经元组合就得到了神经网络。</p>
<h2 id="感知机"><span class="header-section-number">1.2</span> 感知机</h2>
<p><a href="https://en.wikipedia.org/wiki/Perceptron">感知机</a> 由两层神经元组成，第一层神经元接收输入，输出神经元是M-P神经元，可实现与、或、非等运算，但是某些简单的操作却无法实现（比如异或）。</p>
<p>感知机的学习过程（将<span class="math inline">\(*θ*\)</span>作为<span class="math inline">\({x_0}=-1\)</span>的权重<span class="math inline">\(w_0\)</span>）为： <span class="math display">\[w_i←*w*_*i* + △*w*_*i*\]</span> <span class="math display">\[△*w*_*i*=*η*(y-)x_i\]</span> 其中<span class="math inline">\(*η*∈(0,1)\)</span>为学习率。对于 <strong>线性可分</strong> 的问题，感知机的学习过程一定会收敛。</p>
<h2 id="多层神经网络"><span class="header-section-number">1.3</span> 多层神经网络</h2>
<p>对于线性不可分的问题，则需要使用多层网络进行解决，即每层神经元与下层神经元完全连接，同层之间不存在连接，也没有跨层的连接，除开输入层与输出层的中间层为 <em>hidden layer</em> ，隐层与输出层包含功能神经元，输入层仅接收输入，典型的多层网络比如<a href="https://en.wikipedia.org/wiki/Feedforward_neural_network">多层前馈神经网络</a>。</p>
<h2 id="多层感知机mlp"><span class="header-section-number">1.4</span> 多层感知机（MLP）</h2>
<p>多层感知机是一种多层前馈神经网络（数据从输入层进入，流经隐藏层，最后到达输出层），至少需要包含三层layers或者一层hidden layers，训练时使用<a href="https://en.wikipedia.org/wiki/Backpropagation">误差逆传播(Backpropagation)</a>算法。</p>
<h2 id="dnn"><span class="header-section-number">1.5</span> DNN</h2>
<p>DNN也是一种典型的前馈神经网络，单单从结构上来看，也可以理解成隐藏层数更多的MLP。</p>
<h2 id="rnnrecurrent"><span class="header-section-number">1.6</span> RNN（Recurrent）</h2>
<p><a href="https://en.wikipedia.org/wiki/Recurrent_neural_network">RNN</a> 即循环神经网络，对于训练样本是连续的序列，比如连续的语音、连续的文字等情况，难以直接切分成独立的样本进行训练的情况，RNN可以很好的解决。</p>
<h3 id="经典rnn"><span class="header-section-number">1.6.1</span> 经典RNN</h3>
<p>假设时间序列<span class="math inline">\(t\)</span>从1到<span class="math inline">\(*τ*\)</span>，对于其中任意一个序列<span class="math inline">\(t\)</span>，<span class="math inline">\(x^{(t)}\)</span>为当前序列样本的输入，隐藏状态<span class="math inline">\(h{(t)}\)</span>由<span class="math inline">\(x^{(t)}\)</span>和<span class="math inline">\(h{(t-1)}\)</span>共同决定： <span class="math display">\[h^(t)=*σ*(*z*^(*t*))=*σ*(*U**x*^(*t*) + *W**h*^(*t*) + *b*)\]</span> 其中<span class="math inline">\(*σ*\)</span>通常为sigmoid激活函数，对应的输出为： <span class="math display">\[o^{(t)}=Vh{(t)}+c\]</span> 最终在序列<span class="math inline">\(t\)</span>的预测输出为： <span class="math display">\[^(t)=*σ*(*o*^(*t*))\]</span> 而这里的激活函数一般为softmax。整个过程中的<span class="math inline">\(U,V,W,b\)</span>在整个RNN网络中共享（相同），其可以理解每一步都在做相同的事，只是输入不同，这样大大降低了网络中要学习的参数。</p>
<p>如果将感知机比喻为二维平面，那么RNN则可以理解为三位平面，从三位平面的角度看（时间序列），相邻二维平面之间并非独立，而是有所关系。</p>
<ol type="1">
<li><p>N vs. N RNN</p>
<p>这种RNN结构上要求输入序列与输出序列等长，因此比较适用领域较小，著名的Char RNN即属于此类，输入一个字符，计算下一个字符的概率。</p>
<p><img src="https://pic2.zhimg.com/80/v2-629abbab0d5cc871db396f17e9c58631_hd.jpg" /></p></li>
<li><p>N vs. 1 RNN</p>
<p>即输入是一个序列，但是输出是一个单独的值，这种结构通常可以用于序列分类问题（比如实体关系分类、情感倾向分析）。</p>
<p><img src="https://pic1.zhimg.com/80/v2-6caa75392fe47801e605d5e8f2d3a100_hd.jpg" /></p></li>
<li><p>1 vs. N RNN</p>
<p>从图像生成一段文字可以采取这种方式（或者对文章产生摘要？）。</p>
<p><img src="https://pic1.zhimg.com/80/v2-87ebd6a82e32e81657682ffa0ba084ee_hd.jpg" /> <img src="https://pic1.zhimg.com/80/v2-fe054c488bb3a9fbcdfad299b2294266_hd.jpg" /></p></li>
<li><p>N vs. M RNN</p>
<p>通常又叫Encoder-Decoder模型，也叫Seq2Seq模型。这种情况即输入序列长度与输出序列长度不等长，最常见的例子就是机器翻译（原语言和目的语言的长度并不相同）。该模型首先将输入编码成上下文相关的向量(c)，然后使用另一个RNN网络对向量(c)进行解码。</p>
<p><img src="https://pic1.zhimg.com/80/v2-e0fbb46d897400a384873fc100c442db_hd.jpg" /> 由于不限制输入和输出的长度，因此NvM RNN 可用于机器翻译、文本摘要、语音识别（语音到文字序列）</p></li>
</ol>
<h3 id="bi-rnn"><span class="header-section-number">1.6.2</span> Bi-RNN</h3>
<p>为了加入未来的上下文信息，引入了<a href="https://en.wikipedia.org/wiki/Recurrent_neural_network#Bi-directional">双向RNN</a> ，常见的解决思路是在输入和输出之间加入一些延迟，因此延迟的这些输出已经获取到了一定的输入信息，但是如果把延迟设置的过大，整个网络将花费大量的精力用于记忆输入信息，引起建模能力下降。</p>
<h3 id="lstm"><span class="header-section-number">1.6.3</span> LSTM</h3>
<p>传统RNN的问题在于当前的输出<span class="math inline">\(h_t\)</span>和前一隐藏状态<span class="math inline">\(h_t-1\)</span>相关，而和<span class="math inline">\(h_t-2\)</span>间接相关…如此相关性递减，而在有些领域（比如NLP）中，当前输出和前面很远的隐藏状态的输出相关，<a href="http://colah.github.io/posts/2015-08-Understanding-LSTMs/">这篇文章</a> 中举了一个例子：I grew up in France… I speak fluent French_。在这里，French位置根据前面两个单词的预测可能是任何语言，但在前方很远的地方却已经给出了很明显的“提示”。</p>
<p>为了解决这样的问题，<a href="http://www.bioinf.jku.at/publications/older/2604.pdf">Hochreiter &amp; Schmidhuber (1997)</a> 提出了<a href="https://en.wikipedia.org/wiki/Long_short-term_memory">LSTM</a> ，其是经典RNN的变种之一。RNN在处理<span class="math inline">\(x^{(t)}\)</span>和<span class="math inline">\(h(t-1)\)</span>时，使用的是普通的激活函数sigmoid，而LSTM改造了这一块，包含更复杂的结构，简单说来就是在新一时间序列轮时，决定哪些更新哪些不更新。</p>
<p>详细的说来，在RNN中的<span class="math inline">\(*σ*(*z*^*t*)\)</span>这一块，LSTM替换成了<img src="http://colah.github.io/posts/2015-08-Understanding-LSTMs/img/LSTM3-chain.png" /> ，同时不同于RNN，LSTM在隐藏状态<span class="math inline">\(h^(t)\)</span>的基础上还增加了一个 <strong>细胞状态</strong> <span class="math inline">\(C^(t)\)</span>。首先，在<img src="http://colah.github.io/posts/2015-08-Understanding-LSTMs/img/LSTM3-focus-f.png" /> 这里： <span class="math display">\[f^{(t)}=*σ*(*W*_*f* ⋅ \]</span><em>h</em><sup>(<em>t</em> − 1), <em>x</em></sup>(<em>t</em>)<span class="math display">\[ + *b*_*f*)\]</span>\ 该函数的输出值（0～1）决定(C{(t-1)})中有多少保留，有多少丢弃，保留的保留多少，丢弃的丢弃多少。然后<a href="https://upload-images.jianshu.io/upload_images/42741-7fa07e640593f930.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700">input gate</a> 这里由两部分决定新的信息（<span class="math inline">\(h^{(t-1)}\)</span>和<span class="math inline">\(x{(t)}\)</span>）中有多少加入到新的细胞状态<span class="math inline">\(C^{{(t)}\)</span>中： <span class="math display">\[i}{(t)}=*σ*(*W*_*i* ⋅ \]</span><em>h</em><sup>(<em>t</em> − 1), <em>x</em></sup>(<em>t</em>)<span class="math display">\[ + *b*_*i*)\]</span> <span class="math display">\[^{{(t)}=tanh(W_C⋅\]</span><em>h</em><sup>(<em>t</em> − 1), <em>x</em></sup>(<em>t</em>)<span class="math display">\[+b_C)\]</span> 此时可以将<span class="math inline">\(C}{(t-1)}\)</span>更新为<span class="math inline">\(C^{{(t)}\)</span>： <span class="math display">\[C}{(t)}=f^{(t)}/C^{(t-1)}+i{(t)}/{(t)}\]</span> 完成后，会有<a href="https://upload-images.jianshu.io/upload_images/42741-4c9186bf786063d6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700">output gate</a> 来决定细胞状态的什么特征信息可以输出： <span class="math display">\[o^{{(t)}=*σ*(*W*_*o* ⋅ \]</span><em>h</em><sup>(<em>t</em> − 1), <em>x</em></sup>(<em>t</em>)<span class="math display">\[ + *b*_*o*)\]</span> <span class="math display">\[h}{(t)}=o^(t)*tanh(C^(t))\]</span></p>
<ol type="1">
<li><p>Bi-LSTM</p>
<p>结构和Bi-RNN相同，只是其中的隐藏层单元换成了LSTM单元，有LSTM的原理可知其计算量庞大，再加上双向，计算量应该已经远远大于了原始的RNN。</p></li>
</ol>
<h3 id="gru"><span class="header-section-number">1.6.4</span> GRU</h3>
<p>和LSTM不同的是，<a href="https://en.wikipedia.org/wiki/Gated_recurrent_unit">GRU</a> 只有两个gates：reset gate和update gate，虽然gate少了一个，但是GRU复杂性相对较低，并且性能上和LSTM差距不大。其将LSTM上的input gate和forget gate融盒成一个update gate，update gate决定当前<span class="math inline">\(x_t\)</span>对整体意思是否重要，如果不重要，就将当前词一定程度的忽略，直接将<span class="math inline">\(h^{(t-1)}\)</span>传递给<span class="math inline">\(h{(t)}\)</span>，reset gate则用于判断上一隐层单元<span class="math inline">\(h^{(t-1)}\)</span>对当前词<span class="math inline">\(x{(t)}\)</span>的影响力大小，如果影响力较小，则尽量从当前词<span class="math inline">\(x^(t)\)</span>开始表述意思。</p>
<ol type="1">
<li><p>Bi-GRU</p>
<p>结构同Bi-RNN相同，隐藏层单元换成了GRU单元，相较于Bi-LSTM计算量较低，但是性能差别不大。</p></li>
</ol>
<h3 id="attention机制"><span class="header-section-number">1.6.5</span> Attention机制</h3>
<p>在N vs. M版本的RNN中，我们需要将输入encode成单个的向量<span class="math inline">\(c\)</span>，因此<span class="math inline">\(c\)</span>中会包含语句中所有的信息，因此其长度就是模型的性能瓶颈，而Attention机制就是在decode的隐层中的每一层都加入不同的<span class="math inline">\(c_i\)</span>，因此在decode时，其输出不仅与前一隐层的输出有关系，还与encode的时候计算的<span class="math inline">\(c_i\)</span>有关系。</p>
<p>因此可以说，attention机制的实现是通过保留encode时的中间输出结果，然后训练一个模型来对这些输出结果进行选择性的学习并且在decode时将数输出序列与之关联的过程。</p>
<h3 id="tdnn时延神经网络"><span class="header-section-number">1.6.6</span> TDNN（时延神经网络）</h3>
<p><a href="https://blog.csdn.net/richard2357/article/details/16896837">这个博客</a> 很清晰的说明了其结构，TDNN最开始发明于语音识别。语音数据以帧为单位，在传统的神经网络中，将每帧的特征提取出并传入神经网络中进行训练，TDNN则将连续的多帧（即名称“时延”的来历，示例中使用的是2）的特征传入神经网络，随着时间窗口的推移，每个时间窗口都可以计算出当前预测是属于哪一类，最后统计得分即可作出语音识别的判断。</p>
<p>通常在隐层与输出层之间也有延时。</p>
<h2 id="cnn"><span class="header-section-number">1.7</span> CNN</h2>
<p><a href="https://en.wikipedia.org/wiki/Convolutional_neural_network">卷积神经网络</a> 通常用于计算机视觉，对于图像中的同一个物体，如果只是位于不同图像的不同位置，如果使用传统的前馈神经网络，由于其是全联接的，即输入层与隐层之间是完全连接的，则需要不同的样本对所有的位置情况进行覆盖，而无法学习到图像中物体的特征，CNN的隐层单元则是只与输入单元中在图像中“相邻的一部分”连接，而这所谓“相邻的一部分”的选择方式其实就是图像中<a href="http://www.cnblogs.com/nsnow/p/4562308.html">相邻的部分传递给下一层的某个单元</a> ， 同一层中所有单元接收上一层（“一部分”）输入的权重共享，因此CNN中隐藏层中的单元必然比输入层的单元的个数要少。经过卷积层之后的Convolvefeatures还需要进行池化，以克服计算量仍然较大且过拟合的问题，就是在卷积特征的基础上对一个区域进行特定特征的平均值（或者最大值）的计算，以计算后的值代替这个区域，进一步降维。进行卷积和池化的原因都是基于图像具有“静态性”的属性，因此意味着一个图像区域有用的特征极有可能在另一个区域同样的使用。</p>
<h1 id="学习算法"><span class="header-section-number">2</span> 学习算法</h1>
<p>从原理上来说，神经网络同SVM一样，都是将当前线性不可分的空间投射到另一个线性可分的空间中，只是神经网络利用了矩阵（<span class="math inline">\(W\)</span>）的线性变化加上激活函数<span class="math inline">\(f(⋅)\)</span>的非线性变化共同作用来达到投射的目的。一个神经网络，增加一层layer的点数即是增加线性转换的能力，增加layer的层数即是增加非线性转换的能力。线性转换负责对空间进行升维／降维、放大／缩小、旋转和平移，而非线性转换则负责对空间进行“弯曲”。如果将输入层接收的元素比喻为当前所有种类的原子，则随着layers的递进，原子会递进组合成新物质，最终甚至组合成整个万千世界，而这中间的矩阵<span class="math inline">\(W\)</span>则储存着如何从上一层的物质形成新的物质的信息。</p>
<h2 id="gan"><span class="header-section-number">2.1</span> GAN</h2>
<h1 id="参考"><span class="header-section-number">3</span> 参考</h1>
<ul>
<li>周志华，《机器学习》</li>
<li><a href="https://en.wikipedia.org/wiki/Main_Page">wikipedia</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/28054589">完全图解RNN、RNN变体、Seq2Seq、Attention机制</a></li>
<li><a href="http://colah.github.io/posts/2015-08-Understanding-LSTMs/">Understanding LSTM Networks</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/22888385">深层学习为何要“Deep”（上）</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/27642620">YJango的卷积神经网络——介绍</a></li>
<li><a href="http://colah.github.io/posts/2014-03-NN-Manifolds-Topology/">* Neural Networks, Manifolds, and Topology</a></li>
<li><a href="http://colah.github.io/posts/2015-08-Backprop/">* Calculus on Computational Graphs: Backpropagation</a></li>
<li><a href="https://blog.csdn.net/richard2357/article/details/16896837">TDNN时延神经网络</a></li>
</ul>
</body>
</html>
